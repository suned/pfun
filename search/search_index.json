{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Functional, composable, asynchronous, type-safe Python.","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"console_api/","text":"pfun.console.Console dataclass Module that enables printing to stdout and reading from stdin input ( self , prompt = '' ) Get an effect that reads from stdin Examples: >>> greeting = lambda name : f 'Hello { name } ' >>> Console () . input ( 'What is your name? ' ) . map ( greeting ) . run ( None ) what is your name ? # input e.g \"John Doe\" 'Hello John Doe!' Parameters: Name Type Description Default prompt str Prompt to dislay on stdout '' Returns: Type Description Success[str] Effect that reads from stdin print ( self , msg = '' ) Get an effect that prints to stdout Examples: >>> Console () . print ( 'Hello pfun!' ) . run ( None ) Hello pfun ! Parameters: Name Type Description Default msg str Message to print '' Returns: Type Description Success[None] Effect that prints msg to stdout pfun.console.HasConsole Module provider providing the console module pfun . console . print_line ( msg = '' ) Get an Effect that prints to the console and succeeds with None Examples: >>> class Env : ... console = Console () >>> print_line ( 'Hello pfun!' ) . run ( Env ()) Hello pfun ! Parameters: Name Type Description Default msg str Message to print '' Returns: Type Description Effect[HasConsole, NoReturn, None] Effect that prints to the console using the HasConsole provided to run pfun . console . get_line ( prompt = '' ) Get an Effect that reads a str from stdin Examples: >>> class Env : ... console = Console () >>> greeting = lambda name : f 'Hello { name } !' >>> get_line ( 'What is your name? ' ) . map ( greeting ) . run ( Env ()) name ? # input e.g 'John Doe' 'Hello John Doe!' Parameters: Name Type Description Default prompt str prompt to display in console '' Returns: Type Description Effect[HasConsole, NoReturn, str] an Effect that produces a str read from stdin","title":"pfun.console"},{"location":"console_api/#pfun.console.Console","text":"Module that enables printing to stdout and reading from stdin","title":"Console"},{"location":"console_api/#pfun.console.Console.input","text":"Get an effect that reads from stdin Examples: >>> greeting = lambda name : f 'Hello { name } ' >>> Console () . input ( 'What is your name? ' ) . map ( greeting ) . run ( None ) what is your name ? # input e.g \"John Doe\" 'Hello John Doe!' Parameters: Name Type Description Default prompt str Prompt to dislay on stdout '' Returns: Type Description Success[str] Effect that reads from stdin","title":"input()"},{"location":"console_api/#pfun.console.Console.print","text":"Get an effect that prints to stdout Examples: >>> Console () . print ( 'Hello pfun!' ) . run ( None ) Hello pfun ! Parameters: Name Type Description Default msg str Message to print '' Returns: Type Description Success[None] Effect that prints msg to stdout","title":"print()"},{"location":"console_api/#pfun.console.HasConsole","text":"Module provider providing the console module","title":"HasConsole"},{"location":"console_api/#pfun.console.print_line","text":"Get an Effect that prints to the console and succeeds with None Examples: >>> class Env : ... console = Console () >>> print_line ( 'Hello pfun!' ) . run ( Env ()) Hello pfun ! Parameters: Name Type Description Default msg str Message to print '' Returns: Type Description Effect[HasConsole, NoReturn, None] Effect that prints to the console using the HasConsole provided to run","title":"print_line()"},{"location":"console_api/#pfun.console.get_line","text":"Get an Effect that reads a str from stdin Examples: >>> class Env : ... console = Console () >>> greeting = lambda name : f 'Hello { name } !' >>> get_line ( 'What is your name? ' ) . map ( greeting ) . run ( Env ()) name ? # input e.g 'John Doe' 'Hello John Doe!' Parameters: Name Type Description Default prompt str prompt to display in console '' Returns: Type Description Effect[HasConsole, NoReturn, str] an Effect that produces a str read from stdin","title":"get_line()"},{"location":"dict_api/","text":"pfun.dict.Dict dataclass Immutable dictionary class with functional helper methods __contains__ ( self , key ) Test if key is a key in this dictionary Examples: >>> 'key' in Dict ({ 'key' : 'value' }) True Parameters: Name Type Description Default key object The key to test for membership required Returns: Type Description bool True if key is a key in this dictionary, False otherwise __eq__ ( self , other ) Compare self with other Returns: Type Description bool True if keys and associated values are equal, False otherwise __getitem__ ( self , key ) get the value associated with a key Examples: >>> Dict ( key = 'value' )[ 'key' ] 'value' Parameters: Name Type Description Default key ~K the key to retrieve required Return required __init__ ( self , d = {}) Parameters: Name Type Description Default d Mapping[~K, ~V] dict instance to wrap {} __iter__ ( self ) Get an iterator over the keys in this dictionary Examples: >>> tuple ( Dict ({ 'key' : 'value' })) ( 'key' ,) Returns: Type Description Iterator[~K] Iterator of the keys in this dictionary __len__ ( self ) Get the number of key/value pairs in this dictionary Examples: >>> len ( Dict ({ 'key' : 'value' })) 1 Returns: Type Description int Number of key/value pairs in this dictionary copy ( self ) Get a shallow copy of this dictionary. Examples: >>> Dict ({ 'key' : 'value' }) . copy () Dict ({ 'key' : 'value' }) Returns: Type Description Dict[K, V] Copy of this dict get ( self , key ) get the value associated with a key Examples: >>> Dict () . get ( 'key' ) Nothing () >> Dict ({ 'key' : 'value' }) . get ( 'key' ) Just ( 'value' ) Parameters: Name Type Description Default key ~K the key to retrieve required default value to return if the key is not found required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[~V]] Just if key is found in dictionary or default is given, Nothing otherwise items ( self ) Get the keys and values of this dictionary Examples: >>> Dict ({ 'key' : 'value' }) . items () dict_items ([( 'key' , 'value' )]) Returns: Type Description ItemsView[~K, ~V] Keys and values of this dictionary keys ( self ) Get the keys in this dictionary Examples: >>> Dict ({ 'key' : 'value' }) . keys () dict_keys ([ 'key' ]) Returns: Type Description KeysView[~K] Dictionary keys set ( self , key , value ) Combine keys and values from this dictionary with a new dictionary that includes key and value Examples: >>> Dict () . set ( 'key' , 'value' ) { 'key' : 'value' } Parameters: Name Type Description Default key ~K key to add to the new dictionary required value ~V value to associate with key required Returns: Type Description Dict[K, V] new dictionary with existing keys and values in addition to key and value update ( self , other ) Get a copy of this dictionary updated with key/value pairs from other Examples: >>> Dict ({ 'key' : 'value' }) . update ({ 'new_key' : 'new_value' }) Dict ({ 'key' : 'value' , 'new_key' : 'new_value' }) Parameters: Name Type Description Default other Union[Mapping[~K, ~V], Dict[K, V]] Dict to add to keys/values of this dictionary required Returns: Type Description Dict[K, V] copy of self with keys and values added values ( self ) Get the values in this dictionary Examples: >>> Dict ({ 'key' : 'value' }) . values () dict_values ([ 'value' ]) Returns: Type Description ValuesView[~V] Dictionary values without ( self , key ) Get a copy of this dictionary without the mapping associated with key . Examples: >>> Dict ({ 'key' : 'value' }) . without ( 'key' ) Dict ({}) Parameters: Name Type Description Default key ~K The key to remove required Returns: Type Description Dict[K, V] Copy of this dictionary without key","title":"pfun.dict"},{"location":"dict_api/#pfun.dict.Dict","text":"Immutable dictionary class with functional helper methods","title":"Dict"},{"location":"dict_api/#pfun.dict.Dict.__contains__","text":"Test if key is a key in this dictionary Examples: >>> 'key' in Dict ({ 'key' : 'value' }) True Parameters: Name Type Description Default key object The key to test for membership required Returns: Type Description bool True if key is a key in this dictionary, False otherwise","title":"__contains__()"},{"location":"dict_api/#pfun.dict.Dict.__eq__","text":"Compare self with other Returns: Type Description bool True if keys and associated values are equal, False otherwise","title":"__eq__()"},{"location":"dict_api/#pfun.dict.Dict.__getitem__","text":"get the value associated with a key Examples: >>> Dict ( key = 'value' )[ 'key' ] 'value' Parameters: Name Type Description Default key ~K the key to retrieve required Return required","title":"__getitem__()"},{"location":"dict_api/#pfun.dict.Dict.__init__","text":"Parameters: Name Type Description Default d Mapping[~K, ~V] dict instance to wrap {}","title":"__init__()"},{"location":"dict_api/#pfun.dict.Dict.__iter__","text":"Get an iterator over the keys in this dictionary Examples: >>> tuple ( Dict ({ 'key' : 'value' })) ( 'key' ,) Returns: Type Description Iterator[~K] Iterator of the keys in this dictionary","title":"__iter__()"},{"location":"dict_api/#pfun.dict.Dict.__len__","text":"Get the number of key/value pairs in this dictionary Examples: >>> len ( Dict ({ 'key' : 'value' })) 1 Returns: Type Description int Number of key/value pairs in this dictionary","title":"__len__()"},{"location":"dict_api/#pfun.dict.Dict.copy","text":"Get a shallow copy of this dictionary. Examples: >>> Dict ({ 'key' : 'value' }) . copy () Dict ({ 'key' : 'value' }) Returns: Type Description Dict[K, V] Copy of this dict","title":"copy()"},{"location":"dict_api/#pfun.dict.Dict.get","text":"get the value associated with a key Examples: >>> Dict () . get ( 'key' ) Nothing () >> Dict ({ 'key' : 'value' }) . get ( 'key' ) Just ( 'value' ) Parameters: Name Type Description Default key ~K the key to retrieve required default value to return if the key is not found required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[~V]] Just if key is found in dictionary or default is given, Nothing otherwise","title":"get()"},{"location":"dict_api/#pfun.dict.Dict.items","text":"Get the keys and values of this dictionary Examples: >>> Dict ({ 'key' : 'value' }) . items () dict_items ([( 'key' , 'value' )]) Returns: Type Description ItemsView[~K, ~V] Keys and values of this dictionary","title":"items()"},{"location":"dict_api/#pfun.dict.Dict.keys","text":"Get the keys in this dictionary Examples: >>> Dict ({ 'key' : 'value' }) . keys () dict_keys ([ 'key' ]) Returns: Type Description KeysView[~K] Dictionary keys","title":"keys()"},{"location":"dict_api/#pfun.dict.Dict.set","text":"Combine keys and values from this dictionary with a new dictionary that includes key and value Examples: >>> Dict () . set ( 'key' , 'value' ) { 'key' : 'value' } Parameters: Name Type Description Default key ~K key to add to the new dictionary required value ~V value to associate with key required Returns: Type Description Dict[K, V] new dictionary with existing keys and values in addition to key and value","title":"set()"},{"location":"dict_api/#pfun.dict.Dict.update","text":"Get a copy of this dictionary updated with key/value pairs from other Examples: >>> Dict ({ 'key' : 'value' }) . update ({ 'new_key' : 'new_value' }) Dict ({ 'key' : 'value' , 'new_key' : 'new_value' }) Parameters: Name Type Description Default other Union[Mapping[~K, ~V], Dict[K, V]] Dict to add to keys/values of this dictionary required Returns: Type Description Dict[K, V] copy of self with keys and values added","title":"update()"},{"location":"dict_api/#pfun.dict.Dict.values","text":"Get the values in this dictionary Examples: >>> Dict ({ 'key' : 'value' }) . values () dict_values ([ 'value' ]) Returns: Type Description ValuesView[~V] Dictionary values","title":"values()"},{"location":"dict_api/#pfun.dict.Dict.without","text":"Get a copy of this dictionary without the mapping associated with key . Examples: >>> Dict ({ 'key' : 'value' }) . without ( 'key' ) Dict ({}) Parameters: Name Type Description Default key ~K The key to remove required Returns: Type Description Dict[K, V] Copy of this dictionary without key","title":"without()"},{"location":"effect_api/","text":"pfun.effect.Effect __call__ Run the function wrapped by this Effect asynchronously, including potential side-effects. If the function fails the resulting error will be raised as an exception. Parameters: Name Type Description Default self Effect[R, E, A] required r R The dependency with which to run this Effect required max_processes Optional[int] The max number of processes used to run cpu bound parts of this effect required max_threads Optional[int] The max number of threads used to run io bound parts of this effect required Returns: Type Description Awaitable[A] The succesful result of the wrapped function if it succeeds Exceptions: Type Description E If the Effect fails and E is a subclass of Exception RuntimeError if the effect fails and E is not a subclass of Exception and_then ( self , f ) Create new Effect that applies f to the result of running this effect successfully. If this Effect fails, f is not applied. Examples: >>> success ( 2 ) . and_then ( lambda i : success ( i + 2 )) . run ( None ) 4 Parameters: Name Type Description Default self Effect[R, E, A] required f A -> Effect[Any, E2, B] Function to pass the result of this Effect instance once it can be computed required Returns: Type Description Effect[Any, Union[E, E2], B] New Effect which wraps the result of passing the result of this Effect instance to f discard_and_then ( self , effect ) Create a new effect that discards the result of this effect, and produces instead effect . Like and_then but does not require you to handle the result. Convenient for effects that produce None , like writing to files. Examples: >>> from pfun import files >>> class Env : ... files = files . Files () >>> files . write ( 'foo.txt' , 'Hello!' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( Env ()) Hello ! Parameters: Name Type Description Default self Effect[R, E, A] required effect Effect[Any, E2, B] Effect instance to run after this Effect has run successfully. required Returns: Type Description Effect[Any, Union[E, E2], B] New effect that succeeds with effect either ( self ) Push the potential error into the success channel as an either, allowing error handling. Examples: >>> error ( 'Whoops!' ) . either () . map ( ... lambda either : either . get if isinstance ( either , Right ) ... else 'Phew!' ... ) . run ( None ) 'Phew!' Parameters: Name Type Description Default self Effect[R, E, A] required Returns: Type Description Effect[R, NoReturn, Either[E, A]] New Effect that produces a Left[E] if it has failed, or a : Right[A] if it succeeds ensure ( self , effect ) Create an Effect that will always run effect , regardless of whether this Effect succeeds or fails. The result of effect is ignored, and the resulting effect instead succeeds or fails with the succes or error value of this effect. Useful for closing resources. Examples: >>> from pfun.effect.console import Console >>> console = Console () >>> finalizer = console . print ( 'finalizing!' ) >>> success ( 'result' ) . ensure ( finalizer ) . run ( None ) finalizing ! 'result' >>> error ( 'whoops!' ) . ensure ( finalizer ) . run ( None ) finalizing ! RuntimeError : whoops ! Parameters: Name Type Description Default self Effect[R, E, A] required effect Effect[Any, NoReturn, Any] Effect to run after this effect terminates either successfully or with an error required Returns: Type Description Effect[Any, E, A] Effect that fails or succeeds with the result of this effect, but always runs effect map ( self , f ) Map f over the result produced by this Effect once it is run Examples: >>> success ( 2 ) . map ( lambda v : v + 2 ) . run ( None ) 4 Parameters: Name Type Description Default self Effect[R, E, A] required f A -> B function to map over this Effect required Returns: Type Description Effect[R, E, B] new Effect with f applied to the value produced by this Effect . memoize ( self ) Create an Effect that caches its result. When the effect is evaluated for the second time, its side-effects are not performed, it simply succeeds with the cached result. This means you should be careful with memoizing complicated effects. Useful for effects that have expensive results, such as calling a slow HTTP api or reading a large file. Examples: >>> from pfun.console import Console >>> console = Console () >>> effect = console . print ( ... 'Doing something expensive' ... ) . discard_and_then ( ... success ( 'result' ) ... ) . memoize () >>> # this would normally cause an effect to be run twice. >>> double_effect = effect . discard_and_then ( effect ) >>> double_effect . run ( None ) Doing something expensive 'result' Parameters: Name Type Description Default self Effect[R, E, A] required Returns: Type Description Effect[R, E, A] memoized Effect recover ( self , f ) Create new Effect that applies f to the error result of running this effect if it fails. If this Effect succeeds, f is not applied. Examples: >>> error ( 'Whoops!' ) . recover ( lambda _ : success ( 'Phew!' )) . run ( None ) 'Phew!' Parameters: Name Type Description Default self Effect[R, E, A] required f E -> Effect[Any, E2, B] Function to pass the error result of this Effect instance once it can be computed required Returns: Type Description Effect[Any, E2, Union[A, B]] New : Effect which wraps the result of passing the error result of this Effect instance to f run ( self , env , max_processes , max_threads ) Run the function wrapped by this Effect , including potential side-effects. If the function fails the resulting error will be raised as an exception. Parameters: Name Type Description Default self Effect[R, E, A] required r R The dependency with which to run this Effect required max_processes Optional[int] The max number of processes used to run cpu bound parts of this effect required max_threads Optional[int] The max number of threads used to run io bound parts of this effect required Returns: Type Description A The succesful result of the wrapped function if it succeeds Exceptions: Type Description E If the Effect fails and E is a subclass of Exception RuntimeError if the effect fails and E is not a subclass of Exception pfun . effect . Success : TypeAlias Type-alias for Effect[object, NoReturn, TypeVar('A')] . pfun . effect . Try : TypeAlias Type-alias for Effect[object, TypeVar('E'), TypeVar('A')] . pfun . effect . Depends : TypeAlias Type-alias for Effect[TypeVar('R'), NoReturn, TypeVar('A')] . pfun . effect . success ( result ) Wrap a function in Effect that does nothing but return value Examples: >>> success ( 'Yay!' ) . run ( None ) 'Yay!' Parameters: Name Type Description Default value A The value to return when the Effect is executed required Returns: Type Description Success[A] Effect that wraps a function returning value pfun . effect . error ( reason ) Create an Effect that does nothing but fail with reason Examples: >>> error ( 'Whoops!' ) . run ( None ) RuntimeError : 'Whoops!' Parameters: Name Type Description Default reason E Value to fail with required Returns: Type Description Effect[object, E, NoReturn] Effect that fails with reason pfun . effect . depend ( r_type = None ) Get an Effect that produces the dependency passed to run when executed Examples: >>> depend ( str ) . run ( 'dependency' ) 'dependency' Parameters: Name Type Description Default r_type R The expected dependency type of the resulting effect. Used ONLY for type-checking and doesn't impact runtime behaviour in any way None Returns: Type Description Effect[R, NoReturn, R] Effect that produces the dependency passed to run pfun . effect . sequence_async ( effects ) Evaluate each Effect in iterable asynchronously and collect the results Examples: >>> sequence_async ([ success ( v ) for v in range ( 3 )]) . run ( None ) ( 0 , 1 , 2 ) Parameters: Name Type Description Default iterable Iterable[Effect[R, E, A]] The iterable to collect results from required Returns: Type Description Effect[R, E, Iterable[A]] Effect that produces collected results pfun . effect . filter_ ( f , iterable ) Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : success ( v % 2 == 0 ), range ( 3 )) . run ( None ) ( 0 , 2 ) Parameters: Name Type Description Default f A -> Effect[R, E, bool] Function to map iterable by required iterable Iterable[A] Iterable to map by f required Returns: Type Description Effect[R, E, Iterable[A]] iterable mapped and filtered by f pfun . effect . for_each ( f , iterable ) Map each in element in iterable to an Effect by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( success , range ( 3 )) . run ( None ) ( 0 , 1 , 2 ) Parameters: Name Type Description Default f A -> Effect[R, E, B] Function to map over iterable required iterable Iterable[A] Iterable to map f over required Returns: Type Description Effect[R, E, Iterable[B]] f mapped over iterable and combined from left to right. pfun . effect . absolve ( effect ) Move the error type from an Effect producing an Either into the error channel of the Effect Examples: >>> effect = error ( 'Whoops' ) . either () . map ( ... lambda either : either . get if isinstance ( either , Right ) ... else 'Phew!' ... ) >>> absolve ( effect ) . run ( None ) 'Phew!' Parameters: Name Type Description Default effect Effect[R, NoReturn, Either[E, A]] an Effect producing an Either required Returns: Type Description Effect[R, E, A] an Effect failing with E or succeeding with A pfun . effect . combine ( * effects ) Create an effect that produces the result of calling the passed function with the results of effects in effects Examples: >>> combine ( success ( 2 ), success ( 2 ))( lambda a , b : a + b ) . run ( None ) 4 Parameters: Name Type Description Default effects Effect[R, E, A] Effects the results of which to pass to the combiner function () Returns: Type Description (((*A, **B) -> C) -> *Effect[R, E, A] -> Effect[R, E, C]) function that takes a combiner function and returns an Effect that applies the function to the results of effects pfun . effect . lift ( f ) Decorator that enables decorated functions to operate on Effect instances. Note that the returned function does not accept keyword arguments. Examples: >>> def add ( a : int , b : int ) -> int : ... return a + b >>> lift ( add )( success ( 2 ), success ( 2 )) . run ( None ) 4 Parameters: Name Type Description Default f (*A, **B) -> C The function to decorate required Returns: Type Description (*Effect[R, E, A] -> Effect[R, E, C]) The decorated function pfun . effect . lift_cpu_bound ( f ) Decorator that enables decorated cpu bound functions to operate on Effect instances. Note that the returned function does not accept keyword arguments. Examples: >>> def add ( a : int , b : int ) -> int : ... return a + b >>> lift_cpu_bound ( add )( success ( 2 ), success ( 2 )) . run ( None ) 4 Parameters: Name Type Description Default f (*A, **B) -> C The function to decorate required Returns: Type Description (*Effect[R, E, A] -> Effect[R, E, C]) The decorated function pfun . effect . lift_io_bound ( f ) Decorator that enables decorated io bound functions to operate on Effect instances. Note that the returned function does not accept keyword arguments. Examples: >>> def add ( a : int , b : int ) -> int : ... return a + b >>> lift_io_bound ( add )( success ( 2 ), success ( 2 )) . run ( None ) 4 Parameters: Name Type Description Default f (*A, **B) -> C The function to decorate required Returns: Type Description (*Effect[R, E, A] -> Effect[R, E, C]) The decorated function pfun . effect . catch ( exception , * exceptions ) Decorator that catches errors as an Effect . If the decorated function performs additional side-effects, they are not carried out until the effect is run. Examples: >>> f = catch ( ZeroDivisionError )( lambda v : 1 / v ) >>> f ( 1 ) . run ( None ) 1.0 >>> f ( 0 ) . run ( None ) ZeroDivisionError Parameters: Name Type Description Default exception Exception The first exception to catch required exceptions Exception Remaining exceptions to catch () Returns: Type Description ((*args, **kwargs) -> A) -> Effect[object, Exception, A] Decorator of functions that handle expection arguments as an Effect . pfun . effect . catch_cpu_bound ( exception , * exceptions ) Decorator that catches errors from a cpu bound function as an Effect . If the decorated function performs additional side-effects, they are not carried out until the effect is run. Examples: >>> f = catch_cpu_bound ( ZeroDivisionError )( lambda v : 1 / v ) >>> f ( 1 ) . run ( None ) 1.0 >>> f ( 0 ) . run ( None ) ZeroDivisionError Parameters: Name Type Description Default exception Exception The first exception to catch required exceptions Exception Remaining exceptions to catch () Returns: Type Description ((*args, **kwargs) -> A) -> Effect[object, Exception, A] Decorator of functions that handle expection arguments as an Effect . pfun . effect . catch_io_bound ( exception , * exceptions ) Decorator that catches errors from an io bound function as an Effect . If the decorated function performs additional side-effects, they are not carried out until the effect is run. Examples: >>> f = catch_io_bound ( ZeroDivisionError )( lambda v : 1 / v ) >>> f ( 1 ) . run ( None ) 1.0 >>> f ( 0 ) . run ( None ) ZeroDivisionError Parameters: Name Type Description Default exception Exception The first exception to catch required exceptions Exception Remaining exceptions to catch () Returns: Type Description ((*args, **kwargs) -> A) -> Effect[object, Exception, A] Decorator of functions that handle expection arguments as an Effect . pfun . effect . from_awaitable ( awaitable ) Create an Effect that produces the result of awaiting awaitable Examples: >>> async def f () -> str : ... return 'Yay!' >>> from_awaitable ( f ()) . run ( None ) 'Yay' Parameters: Name Type Description Default awaitable Awaitable[A] Awaitable to await in the resulting Effect required Returns: Type Description Success[A] Effect that produces the result of awaiting awaitable pfun . effect . from_callable ( f ) Create an Effect from a function that takes a dependency and returns an Either Examples: >>> from pfun.either import Either , Left , Right >>> def f ( r : str ) -> Either [ str , str ]: ... if not r : ... return Left ( 'Empty string' ) ... return Right ( r * 2 ) >>> effect = from_callable ( f ) >>> effect . run ( '' ) RuntimeError : Empty string >>> effect . run ( 'Hello!' ) Hello ! Hello ! Parameters: Name Type Description Default f R -> Either[E, A] the function to turn into an Effect required Returns: Type Description Effect[R, E, A] f as an Effect pfun . effect . from_cpu_bound_callable ( f ) Create an Effect from a cpu bound function that takes a dependency and returns an Either Examples: >>> from pfun.either import Either , Left , Right >>> def f ( r : str ) -> Either [ str , str ]: ... if not r : ... return Left ( 'Empty string' ) ... return Right ( r * 2 ) >>> effect = from_cpu_bound_callable ( f ) >>> effect . run ( '' ) RuntimeError : Empty string >>> effect . run ( 'Hello!' ) Hello ! Hello ! Parameters: Name Type Description Default f R -> Either[E, A] the function to turn into an Effect required Returns: Type Description Effect[R, E, A] f as an Effect pfun . effect . from_io_bound_callable ( f ) Create an Effect from an io bound function that takes a dependency and returns an Either Examples: >>> from pfun.either import Either , Left , Right >>> def f ( r : str ) -> Either [ str , str ]: ... if not r : ... return Left ( 'Empty string' ) ... return Right ( r * 2 ) >>> effect = from_io_bound_callable ( f ) >>> effect . run ( '' ) RuntimeError : Empty string >>> effect . run ( 'Hello!' ) Hello ! Hello ! Parameters: Name Type Description Default f R -> Either[E, A] the function to turn into an Effect required Returns: Type Description Effect[R, E, A] f as an Effect","title":"pfun.effect"},{"location":"effect_api/#pfun.effect.Effect","text":"","title":"Effect"},{"location":"effect_api/#pfun.effect.Effect.__call__","text":"Run the function wrapped by this Effect asynchronously, including potential side-effects. If the function fails the resulting error will be raised as an exception. Parameters: Name Type Description Default self Effect[R, E, A] required r R The dependency with which to run this Effect required max_processes Optional[int] The max number of processes used to run cpu bound parts of this effect required max_threads Optional[int] The max number of threads used to run io bound parts of this effect required Returns: Type Description Awaitable[A] The succesful result of the wrapped function if it succeeds Exceptions: Type Description E If the Effect fails and E is a subclass of Exception RuntimeError if the effect fails and E is not a subclass of Exception","title":"__call__()"},{"location":"effect_api/#pfun.effect.Effect.and_then","text":"Create new Effect that applies f to the result of running this effect successfully. If this Effect fails, f is not applied. Examples: >>> success ( 2 ) . and_then ( lambda i : success ( i + 2 )) . run ( None ) 4 Parameters: Name Type Description Default self Effect[R, E, A] required f A -> Effect[Any, E2, B] Function to pass the result of this Effect instance once it can be computed required Returns: Type Description Effect[Any, Union[E, E2], B] New Effect which wraps the result of passing the result of this Effect instance to f","title":"and_then()"},{"location":"effect_api/#pfun.effect.Effect.discard_and_then","text":"Create a new effect that discards the result of this effect, and produces instead effect . Like and_then but does not require you to handle the result. Convenient for effects that produce None , like writing to files. Examples: >>> from pfun import files >>> class Env : ... files = files . Files () >>> files . write ( 'foo.txt' , 'Hello!' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( Env ()) Hello ! Parameters: Name Type Description Default self Effect[R, E, A] required effect Effect[Any, E2, B] Effect instance to run after this Effect has run successfully. required Returns: Type Description Effect[Any, Union[E, E2], B] New effect that succeeds with effect","title":"discard_and_then()"},{"location":"effect_api/#pfun.effect.Effect.either","text":"Push the potential error into the success channel as an either, allowing error handling. Examples: >>> error ( 'Whoops!' ) . either () . map ( ... lambda either : either . get if isinstance ( either , Right ) ... else 'Phew!' ... ) . run ( None ) 'Phew!' Parameters: Name Type Description Default self Effect[R, E, A] required Returns: Type Description Effect[R, NoReturn, Either[E, A]] New Effect that produces a Left[E] if it has failed, or a : Right[A] if it succeeds","title":"either()"},{"location":"effect_api/#pfun.effect.Effect.ensure","text":"Create an Effect that will always run effect , regardless of whether this Effect succeeds or fails. The result of effect is ignored, and the resulting effect instead succeeds or fails with the succes or error value of this effect. Useful for closing resources. Examples: >>> from pfun.effect.console import Console >>> console = Console () >>> finalizer = console . print ( 'finalizing!' ) >>> success ( 'result' ) . ensure ( finalizer ) . run ( None ) finalizing ! 'result' >>> error ( 'whoops!' ) . ensure ( finalizer ) . run ( None ) finalizing ! RuntimeError : whoops ! Parameters: Name Type Description Default self Effect[R, E, A] required effect Effect[Any, NoReturn, Any] Effect to run after this effect terminates either successfully or with an error required Returns: Type Description Effect[Any, E, A] Effect that fails or succeeds with the result of this effect, but always runs effect","title":"ensure()"},{"location":"effect_api/#pfun.effect.Effect.map","text":"Map f over the result produced by this Effect once it is run Examples: >>> success ( 2 ) . map ( lambda v : v + 2 ) . run ( None ) 4 Parameters: Name Type Description Default self Effect[R, E, A] required f A -> B function to map over this Effect required Returns: Type Description Effect[R, E, B] new Effect with f applied to the value produced by this Effect .","title":"map()"},{"location":"effect_api/#pfun.effect.Effect.memoize","text":"Create an Effect that caches its result. When the effect is evaluated for the second time, its side-effects are not performed, it simply succeeds with the cached result. This means you should be careful with memoizing complicated effects. Useful for effects that have expensive results, such as calling a slow HTTP api or reading a large file. Examples: >>> from pfun.console import Console >>> console = Console () >>> effect = console . print ( ... 'Doing something expensive' ... ) . discard_and_then ( ... success ( 'result' ) ... ) . memoize () >>> # this would normally cause an effect to be run twice. >>> double_effect = effect . discard_and_then ( effect ) >>> double_effect . run ( None ) Doing something expensive 'result' Parameters: Name Type Description Default self Effect[R, E, A] required Returns: Type Description Effect[R, E, A] memoized Effect","title":"memoize()"},{"location":"effect_api/#pfun.effect.Effect.recover","text":"Create new Effect that applies f to the error result of running this effect if it fails. If this Effect succeeds, f is not applied. Examples: >>> error ( 'Whoops!' ) . recover ( lambda _ : success ( 'Phew!' )) . run ( None ) 'Phew!' Parameters: Name Type Description Default self Effect[R, E, A] required f E -> Effect[Any, E2, B] Function to pass the error result of this Effect instance once it can be computed required Returns: Type Description Effect[Any, E2, Union[A, B]] New : Effect which wraps the result of passing the error result of this Effect instance to f","title":"recover()"},{"location":"effect_api/#pfun.effect.Effect.run","text":"Run the function wrapped by this Effect , including potential side-effects. If the function fails the resulting error will be raised as an exception. Parameters: Name Type Description Default self Effect[R, E, A] required r R The dependency with which to run this Effect required max_processes Optional[int] The max number of processes used to run cpu bound parts of this effect required max_threads Optional[int] The max number of threads used to run io bound parts of this effect required Returns: Type Description A The succesful result of the wrapped function if it succeeds Exceptions: Type Description E If the Effect fails and E is a subclass of Exception RuntimeError if the effect fails and E is not a subclass of Exception","title":"run()"},{"location":"effect_api/#pfun.effect.Success","text":"Type-alias for Effect[object, NoReturn, TypeVar('A')] .","title":"Success"},{"location":"effect_api/#pfun.effect.Try","text":"Type-alias for Effect[object, TypeVar('E'), TypeVar('A')] .","title":"Try"},{"location":"effect_api/#pfun.effect.Depends","text":"Type-alias for Effect[TypeVar('R'), NoReturn, TypeVar('A')] .","title":"Depends"},{"location":"effect_api/#pfun.effect.success","text":"Wrap a function in Effect that does nothing but return value Examples: >>> success ( 'Yay!' ) . run ( None ) 'Yay!' Parameters: Name Type Description Default value A The value to return when the Effect is executed required Returns: Type Description Success[A] Effect that wraps a function returning value","title":"success()"},{"location":"effect_api/#pfun.effect.error","text":"Create an Effect that does nothing but fail with reason Examples: >>> error ( 'Whoops!' ) . run ( None ) RuntimeError : 'Whoops!' Parameters: Name Type Description Default reason E Value to fail with required Returns: Type Description Effect[object, E, NoReturn] Effect that fails with reason","title":"error()"},{"location":"effect_api/#pfun.effect.depend","text":"Get an Effect that produces the dependency passed to run when executed Examples: >>> depend ( str ) . run ( 'dependency' ) 'dependency' Parameters: Name Type Description Default r_type R The expected dependency type of the resulting effect. Used ONLY for type-checking and doesn't impact runtime behaviour in any way None Returns: Type Description Effect[R, NoReturn, R] Effect that produces the dependency passed to run","title":"depend()"},{"location":"effect_api/#pfun.effect.sequence_async","text":"Evaluate each Effect in iterable asynchronously and collect the results Examples: >>> sequence_async ([ success ( v ) for v in range ( 3 )]) . run ( None ) ( 0 , 1 , 2 ) Parameters: Name Type Description Default iterable Iterable[Effect[R, E, A]] The iterable to collect results from required Returns: Type Description Effect[R, E, Iterable[A]] Effect that produces collected results","title":"sequence_async()"},{"location":"effect_api/#pfun.effect.filter_","text":"Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : success ( v % 2 == 0 ), range ( 3 )) . run ( None ) ( 0 , 2 ) Parameters: Name Type Description Default f A -> Effect[R, E, bool] Function to map iterable by required iterable Iterable[A] Iterable to map by f required Returns: Type Description Effect[R, E, Iterable[A]] iterable mapped and filtered by f","title":"filter_()"},{"location":"effect_api/#pfun.effect.for_each","text":"Map each in element in iterable to an Effect by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( success , range ( 3 )) . run ( None ) ( 0 , 1 , 2 ) Parameters: Name Type Description Default f A -> Effect[R, E, B] Function to map over iterable required iterable Iterable[A] Iterable to map f over required Returns: Type Description Effect[R, E, Iterable[B]] f mapped over iterable and combined from left to right.","title":"for_each()"},{"location":"effect_api/#pfun.effect.absolve","text":"Move the error type from an Effect producing an Either into the error channel of the Effect Examples: >>> effect = error ( 'Whoops' ) . either () . map ( ... lambda either : either . get if isinstance ( either , Right ) ... else 'Phew!' ... ) >>> absolve ( effect ) . run ( None ) 'Phew!' Parameters: Name Type Description Default effect Effect[R, NoReturn, Either[E, A]] an Effect producing an Either required Returns: Type Description Effect[R, E, A] an Effect failing with E or succeeding with A","title":"absolve()"},{"location":"effect_api/#pfun.effect.combine","text":"Create an effect that produces the result of calling the passed function with the results of effects in effects Examples: >>> combine ( success ( 2 ), success ( 2 ))( lambda a , b : a + b ) . run ( None ) 4 Parameters: Name Type Description Default effects Effect[R, E, A] Effects the results of which to pass to the combiner function () Returns: Type Description (((*A, **B) -> C) -> *Effect[R, E, A] -> Effect[R, E, C]) function that takes a combiner function and returns an Effect that applies the function to the results of effects","title":"combine()"},{"location":"effect_api/#pfun.effect.lift","text":"Decorator that enables decorated functions to operate on Effect instances. Note that the returned function does not accept keyword arguments. Examples: >>> def add ( a : int , b : int ) -> int : ... return a + b >>> lift ( add )( success ( 2 ), success ( 2 )) . run ( None ) 4 Parameters: Name Type Description Default f (*A, **B) -> C The function to decorate required Returns: Type Description (*Effect[R, E, A] -> Effect[R, E, C]) The decorated function","title":"lift()"},{"location":"effect_api/#pfun.effect.lift_cpu_bound","text":"Decorator that enables decorated cpu bound functions to operate on Effect instances. Note that the returned function does not accept keyword arguments. Examples: >>> def add ( a : int , b : int ) -> int : ... return a + b >>> lift_cpu_bound ( add )( success ( 2 ), success ( 2 )) . run ( None ) 4 Parameters: Name Type Description Default f (*A, **B) -> C The function to decorate required Returns: Type Description (*Effect[R, E, A] -> Effect[R, E, C]) The decorated function","title":"lift_cpu_bound()"},{"location":"effect_api/#pfun.effect.lift_io_bound","text":"Decorator that enables decorated io bound functions to operate on Effect instances. Note that the returned function does not accept keyword arguments. Examples: >>> def add ( a : int , b : int ) -> int : ... return a + b >>> lift_io_bound ( add )( success ( 2 ), success ( 2 )) . run ( None ) 4 Parameters: Name Type Description Default f (*A, **B) -> C The function to decorate required Returns: Type Description (*Effect[R, E, A] -> Effect[R, E, C]) The decorated function","title":"lift_io_bound()"},{"location":"effect_api/#pfun.effect.catch","text":"Decorator that catches errors as an Effect . If the decorated function performs additional side-effects, they are not carried out until the effect is run. Examples: >>> f = catch ( ZeroDivisionError )( lambda v : 1 / v ) >>> f ( 1 ) . run ( None ) 1.0 >>> f ( 0 ) . run ( None ) ZeroDivisionError Parameters: Name Type Description Default exception Exception The first exception to catch required exceptions Exception Remaining exceptions to catch () Returns: Type Description ((*args, **kwargs) -> A) -> Effect[object, Exception, A] Decorator of functions that handle expection arguments as an Effect .","title":"catch()"},{"location":"effect_api/#pfun.effect.catch_cpu_bound","text":"Decorator that catches errors from a cpu bound function as an Effect . If the decorated function performs additional side-effects, they are not carried out until the effect is run. Examples: >>> f = catch_cpu_bound ( ZeroDivisionError )( lambda v : 1 / v ) >>> f ( 1 ) . run ( None ) 1.0 >>> f ( 0 ) . run ( None ) ZeroDivisionError Parameters: Name Type Description Default exception Exception The first exception to catch required exceptions Exception Remaining exceptions to catch () Returns: Type Description ((*args, **kwargs) -> A) -> Effect[object, Exception, A] Decorator of functions that handle expection arguments as an Effect .","title":"catch_cpu_bound()"},{"location":"effect_api/#pfun.effect.catch_io_bound","text":"Decorator that catches errors from an io bound function as an Effect . If the decorated function performs additional side-effects, they are not carried out until the effect is run. Examples: >>> f = catch_io_bound ( ZeroDivisionError )( lambda v : 1 / v ) >>> f ( 1 ) . run ( None ) 1.0 >>> f ( 0 ) . run ( None ) ZeroDivisionError Parameters: Name Type Description Default exception Exception The first exception to catch required exceptions Exception Remaining exceptions to catch () Returns: Type Description ((*args, **kwargs) -> A) -> Effect[object, Exception, A] Decorator of functions that handle expection arguments as an Effect .","title":"catch_io_bound()"},{"location":"effect_api/#pfun.effect.from_awaitable","text":"Create an Effect that produces the result of awaiting awaitable Examples: >>> async def f () -> str : ... return 'Yay!' >>> from_awaitable ( f ()) . run ( None ) 'Yay' Parameters: Name Type Description Default awaitable Awaitable[A] Awaitable to await in the resulting Effect required Returns: Type Description Success[A] Effect that produces the result of awaiting awaitable","title":"from_awaitable()"},{"location":"effect_api/#pfun.effect.from_callable","text":"Create an Effect from a function that takes a dependency and returns an Either Examples: >>> from pfun.either import Either , Left , Right >>> def f ( r : str ) -> Either [ str , str ]: ... if not r : ... return Left ( 'Empty string' ) ... return Right ( r * 2 ) >>> effect = from_callable ( f ) >>> effect . run ( '' ) RuntimeError : Empty string >>> effect . run ( 'Hello!' ) Hello ! Hello ! Parameters: Name Type Description Default f R -> Either[E, A] the function to turn into an Effect required Returns: Type Description Effect[R, E, A] f as an Effect","title":"from_callable()"},{"location":"effect_api/#pfun.effect.from_cpu_bound_callable","text":"Create an Effect from a cpu bound function that takes a dependency and returns an Either Examples: >>> from pfun.either import Either , Left , Right >>> def f ( r : str ) -> Either [ str , str ]: ... if not r : ... return Left ( 'Empty string' ) ... return Right ( r * 2 ) >>> effect = from_cpu_bound_callable ( f ) >>> effect . run ( '' ) RuntimeError : Empty string >>> effect . run ( 'Hello!' ) Hello ! Hello ! Parameters: Name Type Description Default f R -> Either[E, A] the function to turn into an Effect required Returns: Type Description Effect[R, E, A] f as an Effect","title":"from_cpu_bound_callable()"},{"location":"effect_api/#pfun.effect.from_io_bound_callable","text":"Create an Effect from an io bound function that takes a dependency and returns an Either Examples: >>> from pfun.either import Either , Left , Right >>> def f ( r : str ) -> Either [ str , str ]: ... if not r : ... return Left ( 'Empty string' ) ... return Right ( r * 2 ) >>> effect = from_io_bound_callable ( f ) >>> effect . run ( '' ) RuntimeError : Empty string >>> effect . run ( 'Hello!' ) Hello ! Hello ! Parameters: Name Type Description Default f R -> Either[E, A] the function to turn into an Effect required Returns: Type Description Effect[R, E, A] f as an Effect","title":"from_io_bound_callable()"},{"location":"effectful_but_side_effect_free/","text":"In functional programming, programs are built by composing functions that have no side-effects . This means that problems that we normally solve using side-effects in imperative programming, such as performing io or raising exceptions, are solved differently. In this section we study the three modules pfun provides for working with side-effects in purely functional style. pfun.maybe helps you deal with missing values without exceptions. pfun.either helps you deal with errors without exceptions. pfun.effect helps you work with side-effects in functional style. If you have some experience with functionl programming, you can probably skip ahead to the section on pfun.effect.Effect . Maybe The job of the pfun.maybe.Maybe type is to help you work with missing values, in much the same way that the built-in None type is used. One of the main disadvantages of the None type is that you end up with logic for dealing with missing values all over the place, using code like if foo is not None . pfun.maybe.Maybe makes things a bit easier by generalising the if foo is not None part as a function called map . Imagine that you have function that looks up values in a dict and returns None if the key isn't found: from typing import Optional def lookup ( d : dict , key : str ) -> Optional [ str ]: try : return d [ key ] except KeyError : return None When using pfun.maybe to do the same thing, you will wrap the result of the lookup in a pfun.maybe.Just instance, and return a pfun.maybe.Nothing instance if the key wasn't found. In other words, it would look like this: from typing import Dict from pfun.maybe import Maybe , Just , Nothing def lookup ( d : Dict [ str , str ], key : str ) -> Maybe [ str ]: try : return Just ( d [ key ]) except KeyError : return Nothing () Now when using the lookup function, instead of checking if the return value is None everytime you call it, you can apply a function to the wrapped value if its not Nothing using map : lookup ({ 'key' : 'value' }, 'key' ) . map ( lambda v : f 'found { v } ' ) But what happens if you map a function that returns a new Just or Nothing ? e.g: def maybe_is_42 ( val : str ) -> Maybe [ str ]: if val == '42' : return Just ( val ) return Nothing () lookup ({ 'key' : '42' }, 'key' ) . map ( maybe_is_42 ) You end up with Just(Just(42)) ! Thats probably not what you wanted. When you want to apply a function that returns Just or Nothing , you should probably use and_then , which knows how to \"unwrap\" the result: lookup ({ 'key' : '42' }, 'key' ) . and_then ( maybe_is_42 ) # Just('42') (For those with previous functional programming experience, and_then is the bind operation of Maybe ) pfun.maybe.Maybe is in fact just a type-alias for Union[Just[TypeVar('A'), Nothing]] . This means that your type checker can figure out when you're dealing with one or the other using either __bool__ or isinstance , just like when using Optional : value = lookup ( some_dict , 'key' ) if value : ... # type checker knows that value is a Just else : ... # type checker knows that value is a Nothing Either One downside of the pfun.maybe.Maybe type is that it's not great for dealing with errors because pfun.maybe.Nothing can't provide any information about what went wrong. pfun.either.Either is a type that's used very similarly to Maybe , but unlike Maybe it can wrap an error value, as well as a success value. Just like when working with Maybe there are two types involved: pfun.either.Right and pfun.either.Left . The Right type is used to wrap successful results by convention. Left is used to wrap errors. Using the lookup function from before as an example, it would like this: from typing import Dict from pfun.either import Either , Right , Left def lookup ( d : Dict [ str , str ], key : str ) -> Either [ Exception , str ]: try : return Right ( d [ key ]) except KeyError as e : return Left ( e ) Just like with Maybe you can apply functions to values wrapped by Right using the map function, and you can transform results into new Either values with and_then : lookup ({ 'key' : 'value' }, 'key' ) . map ( lambda v : f 'found { v } !' ) def is_42 ( value : str ) -> Either [ str , str ]: return Right ( value ) if value == '42' else Left ( 'Wasn \\' t 42' ) lookup ({ 'key' : '42' }) . and_then ( is_42 ) # Right('42') Just like with Maybe , Either is actually a type-alias for Union[Left[TypeVar('L')], Right[TypeVar('R')]] , which allows the type-checker to narrow the type to one or the other using __bool__ or isinstance checks. value = lookup ( some_dict , 'key' ) if value : ... # type checker knows that value is a Right else : ... # type checker knows that value is a Left Effect The pfun.effect.Effect type lets you express side-effects in a side-effect free fashion. Readers with functional programming experience may be familiar with the term \" functional effect system \", which is precisely what pfun.effect.Effect is. The core type you will use when expressing side-effects with pfun is pfun.effect.Effect . Effect has a function run that perfoms the side-effect it represents. run is a function that: Takes exactly one argument May or may not perform side-effects when called (including raising exceptions) You can think of Effect defined as: from typing import TypeVar , Generic from pfun.either import Either R = TypeVar ( 'R' , contravariant = True ) E = TypeVar ( 'E' , covariant = True ) A = TypeVar ( 'A' , covariant = True ) class Effect ( Generic [ R , E , A ]): def run ( self , r : R ) -> A : \"\"\" May raise E \"\"\" ... In other words, Effect takes three type paramaters: R , E and A . We'll study them one at a time. The Success Type The A in Effect[R, E, A] is the success type . This is the type that the effect function will return if no error occurs. For example, in an Effect instance that reads a file as a str , A would be parameterized with str . You can create an Effect instance that succeeds with the value a using pfun.effect.success(a) : from typing import NoReturn from pfun.effect import success , Effect e : Effect [ object , NoReturn , str ] = success ( 'Success!' ) assert e . run ( None ) == 'Success!' (You don't actually have to write the type of e explicitly, as it can be inferred by your type checker. We do it here simply because it's instructive to look at the types). Don't worry about the meaning of object and NoReturn for now, we'll explain that later. For now, just understand that when e has the type Effect[object, NoReturn, str] , it means that when you call e.run with any parameter, it will return a str (the value Success! ). You can work with the success value of an effect using instance methods of Effect . If you want to transform the result of an Effect with a function without side-effects you can use map , which takes a function of the type Callable[[A], B] as an argument, where A is the success type of your effect: e : Effect [ object , NoReturn , str ] = success ( 1 ) . map ( str ) assert e . run ( None ) == \"1\" If you want to transform the result of an Effect with a function that produces other side effects (that is, returns an Effect instance), you use and_then : add_1 = lambda v : success ( v + 1 ) e : Effect [ object , NoReturn , int ] = success ( 1 ) . and_then ( add_1 ) assert e . run ( None ) == 2 (for those with previous functional programming experince, and_then is the \" bind \" operation of Effect ). The Error Type The E in Effect[R, E, A] is the error type . This is type that the run function will raise if it fails. You can create an effect that does nothing but fail using pfun.effect.error : from typing import NoReturn from pfun.effect import Effect , error e : Effect [ object , str , NoReturn ] = error ( 'Whoops!' ) e . run ( None ) # raises: RuntimeError('Whoops!') For a concrete example, take a look at the pfun.files module that helps you read from files: from pfun.effect import Effect from pfun.files import Files files = Files () e : Effect [ object , OSError , str ] = files . read ( 'doesnt_exist.txt' ) e . run ( None ) # raises OSError Don't worry about the api of files for now, simply notice that when e has the type Effect[object, OSError, str] , it means that when you execute e it can produce a str or fail with OSError . Having the the error type explicitly modelled in the type signature of e allows type safe error handling as we'll see later. The Dependency Type Finally, let's look at R in Effect[R, E, A] : the dependency type . R is the argument that run requires to produce its result. It allows you to parameterize the side-effect that your Effect implements which improves re-useability and testability. For example, imagine that you want to use Effect to model the side-effect of reading from a database. The function that reads from the database requires a connection string as an argument to connect. If Effect did not take a parameter you would have to pass around the connection string as a parameter through function calls, all the way down to where the connection string was needed. The dependency type allows you to pass in the connection string at the edge of your program, rather than threading it through a potentially deep stack of function calls: from typing import List , Dict , Any DBRow = Dict [ Any , Any ] def execute ( query : str ) -> Effect [ str , IOError , List [ DBRow ]]: ... def find_row ( results : List [ DBRow ]) -> DBRow : ... def main () -> Effect [ str , IOError , DBRow ]: return execute ( 'select * from users;' ) . map ( find_row ) if __name__ == '__main__' : program = main () # run in production program . run ( 'user@prod_db' ) # run in development program . run ( 'user@dev_db' ) In the next section, we will discuss this dependency injection capability of Effect in detail. The Module Pattern This section is dedicated to the dependency type R . In most examples we have looked at so far, R is parameterized with object . This means that it can safely be called with any value (since all Python values are sub-types of object ). This is mostly useful when you're working with effects that don't use the dependency argument for anything, in which case any value will do. In the previous section we saw how the R parameter of Effect can be used for dependency injection. But what happens when we try to combine two effects with different dependency types with and_then ? The Effect instance returned by and_then must have a dependency type that is a combination of the dependency types of both the combined effects, since the dependency passed to the combined effect is also passed to the other effects. Consider for example this effect, that uses the execute function from above to get database results, and combines it with a function make_request that calls an api, and requires a Credentials instance as the dependency type: class Credentials : ... def make_request ( results : List [ DBRow ]) -> Effect [ Credentials , HTTPError , bytes ]: ... results : effect . Effect [ str , IOError , List [ DBRow ]] = execute ( 'select * from users;' ) response : effect . Effect [ ... , Union [ IOError , HTTPError ], HTTPResponse ] response = results . and_then ( make_request ) response . run ( ... ) # What could this argument be? To call the response.run function, we need an instance of a type that is a str and a Credentials instance at the same time , because that argument must be passed to both the effect returned by execute and by make_request . Ideally, we want response to have the type Effect[Intersection[Credentials, str], IOError, bytes] , where Intersection[Credentials, str] indicates that the dependency type must be both of type Credentials and of type str . In theory such an object could exist (defined as class MyEnv(Credentials, str): ... ), but there are no straight-forward way of expressing that type dynamically in the Python type system. As a consequence, pfun infers the resulting effect with the R parameterized as typing.Any , which in this case means that pfun could not assign a meaningful type to R . If you use the pfun MyPy plugin, you can however redesign the program to follow a pattern that enables pfun to infer a meaningful combined type in much the same way that the error type resulting from combining two effects using and_then can be inferred. This pattern is called the module pattern . In its most basic form, the module pattern simply involves defining a Protocol that serves as the dependency type of an Effect . pfun can combine dependency types of two effects whose dependency types are both protocols, because the combined dependency type is simply a new protocol that inherits from both. This combined protocol is called pfun.Intersection . In many cases the api for effects involved in the module pattern is split into three parts: A module class that provides the actual implementation A module provider that is a typing.Protocol that provides the module class as an attribute Functions that return effects with the module provider class as the dependency type. Lets rewrite our example from before to follow the module pattern: from typing import Protocol from http.client import HTTPError from pfun.effect import Effect , depend class Requests : \"\"\" Requests implementation module \"\"\" def __init__ ( self , credentials : Credentials ): self . credentials = credentials def make_request ( self , results : List [ DBRow ]) -> Effect [ object , HTTPError , bytes ]: ... class HasRequests ( Protocol ): \"\"\" Module provider class for the requests module \"\"\" requests : Requests def make_request ( results : List [ DBRow ]) -> Effect [ HasRequests , HTTPError , bytes ]: \"\"\" Function that returns an effect with the HasRequest module provider as the dependency type \"\"\" return depend ( HasRequests ) . and_then ( lambda env : env . requests . make_request ( results )) class Database : \"\"\" Database implementation module \"\"\" def __init__ ( self , connection_str : str ): self . connection_str = connection_str def execute ( self , query : str ) -> Effect [ object , IOError , List [ DBRow ]]: ... class HasDatabase ( Protocol ): \"\"\" Module provider class for the database module \"\"\" database : Database def execute ( query : str ) -> Effect [ HasDatabase , IOError , List [ DBRow ]]: \"\"\" Function that returns an effect with the HasDatabase module provider as the dependency type \"\"\" return depend ( HasDatabase ) . and_then ( lambda env : env . database . execute ( query )) There are two modules : Requests and Database that provide implementations. There are two corresponding module providers : HasRequests and HasDatabase . Finally there are two functions execute and make_request that puts it all together. Pay attention to the fact that execute and make_request look quite similar: they both start by calling pfun.effect.depend . This function returns an effect that succeeds with the dependency value that will eventually be passed as the argument to the final effect (in this example the effect produced by execute(...).and_then(make_request) ). The optional parameter passed to depend is merely for type-checking purposes, and doesn't change the result in any way. If we combine the new functions execute and make_request that both has protocols as the dependency types, pfun can infer a meaningful type, and make sure that the dependency type that is eventually passed to the whole program provides both the requests and the database attributes: effect = execute ( 'select * from users;' ) . and_then ( make_request ) The type of effect in this case will be Effect [ pfun . Intersection [ HasRequests , HasDatabase ], Union [ HTTPError , IOError ], bytes ] Quite a mouthful, but what it tells us is that effect must be run with an instance of a type that has both the requests and database attributes with appropriate types. In other words, if you accidentally defined your dependency as: class Env : database = Database ( 'user@prod_db' ) effect . run ( Env ()) MyPy would tell you the call effect.run(Env()) is a type error since Env doesn't have a requests attribute. It's worth understanding the module pattern, since pfun uses it pervasively in its api, e.g in pfun.files and pfun.console , in order that pfun can infer the dependency type of effects resulting from combining functions from pfun with user defined functions that also follow the module pattern. A very attractive added bonus of the module pattern is that mocking out particular dependencies of your program becomes extremely simple, and by extension that unit testing becomes easier: from pfun.effect import success from unittest.mock import Mock mock_env = Mock () mock_env . requests . make_request . return_value = success ( b 'Mocked!' ) assert make_request ([])( mock_env ) == b 'Mocked!' Error Handling In this section, we'll look at how to handle errors of effects with type safety. In previous sections we have already spent some time looking at the Effect error type. In many of the examples so far, the error type was typing.NoReturn . An Effect with this error type can never return a value for an error, or in other words, it can never fail (as those effects returned by pfun.effect.success ). In the rest of this section we'll of course be pre-occupied with effects that can fail. When you combine side effects using Effect.and_then , pfun uses typing.Union to combine error types, in order that the resulting effect captures all potential errors in its error type: from typing import List from pfun.files import Files def parse ( content : str ) -> effect . Effect [ object , ZeroDivisionError , List [ int ]]: ... files = Files () e : Effect [ object , Union [ OSError , ZeroDivisionError ], List [ int ]] e = files . read ( 'foo.txt' ) . and_then ( parse ) e has Union[OSError, ZeroDivisionError] as its error type because it can fail if files.read fails, or if parse fails. This compositional aspect of the error type of Effect means that accurate and complex error types are built up from combining simple error types. Moreover, it makes reasoning about error handling easy because errors disappear from the type when they are handled, as we shall see next. The most low level function you can use to handle errors is Effect.either , which surfaces any errors that may have occurred as a pfun.either.Either , where a pfun.either.Right signifies a successful computation and a pfun.either.Left a failed computation: from typing import NoReturn from pfun.effect import Effect , files from pfun.either import Either , Left # files.read can fail with OSError may_have_failed : Effect [ files . HasFiles , OSError , str ] = files . read ( 'foo.txt' ) # calling either() surfaces the OSError in the success type as a pfun.either.Either as_either : Effect [ files . HasFiles , NoReturn , Either [ OSError , str ]] = may_have_failed . either () # we can use map or and_then to handle the error cant_fail : Effect [ files . HasFiles , NoReturn , str ] = as_either . map ( lambda either : 'backup content' if isinstance ( either , Left ) else either . get ) Once you've handled whatever errors you want, you can push the error back into error type of the effect using pfun.effect.absolve : from typing import NoReturn , List from pfun.effect import Effect , absolve , files from pfun.either import Either # function to handle error def handle ( either : Either [ Union [ OSError , ZeroDivisionError ], str ]) -> Either [ ZeroDivisionError , str ]: ... # define an effect that can fail e : Effect [ object , Union [ OSError , ZeroDivisionError ], List [ int ]] = files . read ( 'foo.txt' ) . and_then ( parse ) # handle errors using e.either.map without_os_error : Effect [ object , NoReturn , Either [ OSError , str ]] = e . either () . map ( handle ) # push the remaining error into the error type using absolve e2 : Effect [ object , OSError , str ] = absolve ( without_os_error ) At a slightly higher level, you can use Effect.recover , which takes a function that can inspect the error and handle it. from typing import Union from pfun.effect import success , error , Effect def handle_errors ( reason : Union [ OSError , ZeroDivisionError ]) -> Effect [ object , ZeroDivisionError , str ]: if isinstance ( reason , OSError ): return success ( 'default value' ) return error ( reason ) recovered : Effect [ object , ZeroDivisionError , str ] = e . recover ( handle_errors ) You will frequently handle errors by using isinstance to compare errors with types, so defining your own error types becomes even more important when using pfun to distinguish one error source from another. Concurrency Effect uses asyncio under the hood to run effects asynchronously. This can lead to significant speed ups. Consider for example this program that calls curl http://www.google.com in a subprocess 50 times: # call_google_sync.py import timeit import subprocess [ subprocess . run ([ 'curl' , 'http://www.google.com' ]) for _ in range ( 50 )] Timing the execution using the unix time informs me this takes 5.15 seconds on a normal consumer laptop. Compare this to the program below which does more or less the same thing, but using pfun.subprocess : # call_google_async.py from pfun.subprocess import Subprocess from pfun.effect import sequence_async sp = Subprocess () effect = sequence_async ( sp . run_in_shell ( 'curl http://www.google.com' ) for _ in range ( 50 ) effect . run ( None ) This program finishes in 0.78 seconds, according to time . The crucial difference is the function pfun.effect.sequence_async which returns a new effect that runs its argument effects asynchronously using asyncio . This means that one effect can yield to other effects while waiting for input from the curl subprocess. This ultimately saves a lot of time compared to the synchronous implementation where each call to subprocess.run can only start when the preceeding one has returned. You can create an effect from a Python awaitable using pfun.effect.from_awaitable , allowing you to integrate with asyncio directly in your own code: import asyncio from typing import NoReturn from pfun.effect import from_awaitable , Effect async def sleep () -> str : await asyncio . sleep ( 1 ) return 'success!' e : Effect [ object , NoReturn , str ] = from_awaitable ( sleep ()) assert e . run ( None ) == 'success!' You can also pass async functions directly to map and and_then : from typing import NoReturn import asyncio from pfun.effect import success async def sleep_and_add_1 ( a : int ) -> int : await asyncio . sleep ( 1 ) return a + 1 assert success ( 1 ) . map ( sleep_and_add_1 ) . run ( None ) == 2 When using pfun with async frameworks such as ASGI web servers , you can await the the result of effects using Effect.__call__ (which is really what Effect.run calls using the supplied event-loop): async def f () -> str : e : Effect [ object , NoReturn , str ] = ... return await e ( None ) Purely Functional State Mutating non-local state is a side-effect that we want to avoid when doing functional programming. This means that we need a mechanism for managing state as an effect. pfun.ref provides exactly this. pfun.ref works by mutating state only by calling Effect instances. from typing import Tuple , NoReturn from pfun.ref import Ref from pfun.effect import Effect ref : Ref [ Tuple [ int , ... ]] = Ref (()) add_1 : Effect [ object , NoReturn , None ] = ref . modify ( lambda old : return old + ( 1 ,)) # calling modify doesn't modify the state directly assert ref . value == () # The state is modified only when the effect is called add_1 . run ( None ) assert ref . value == ( 1 ,) pfun.ref.Ref protects access to the state using an asyncio.Lock , meaning that updating the state can be done atomically with the following methods: Ref.get() read the current value of the state Ref.set(new_state) update the state to new_value atomically, meaning no other effect can read the value of the state while the update is in progress. Note that if you first read the state using Ref.get and then set it with Ref.set , other effects may read the value in between which may lead to lost updates. For this use case you should use modify or try_modify Ref.modify(update_function) read and update the state with update_function atomically, meaning no other effect can read or write the state before the effect produced by modify returns Ref.try_modify(update_function) read and update the state with update_function atomically, if update_funciton succeeds. Success is signaled by the update_function by returning a pfun.either.Right instance, and error by returning a pfun.either.Left instance. pfun.ref can of course be combined with the module pattern: from typing import Tuple , NoReturn , Protocol from pfun.ref import Ref from pfun.effect import depend , Effect class HasState ( Protocol ): state : Ref [ Tuple [ int , ... ]] def set_state ( state : Tuple [ int , ... ]) -> Effect [ HasState , NoReturn , None ]: return depend () . and_then ( lambda env . state . set ( state )) Creating Your Own Effects pfun.effect has a number of decorators and helper functions to help you create your own effects. pfun.effect.from_callable is the most flexible option. It takes a function that takes a dependency type and returns a pfun.either.Either and turns it into an effect: from pfun.effect import from_callable , Effect from pfun.either import Either def f ( r : str ) -> Either [ Exception , float ]: ... effect : Effect [ str , Exception , float ] = from_callable ( f ) from_callable may also be used to create effects from async functions: import asyncio async def f ( r : str ) -> Either [ Exception , float ]: await asyncio . sleep ( 1 ) ... effect : Effect [ str , Exception , float ] = from_callable ( f ) pfun.effect.catch is used to decorate sync and async functions that may raise exceptions. If the decorated function performs side effects, they are not carried out until the effect is run from pfun.effect import catch , Effect @catch ( ZeroDivisionError , ValueError ) def f ( v : int ) -> int : if v > 5 : raise ValueError ( 'v is not allowed to be > 5 for some reason' ) return 1 / v effect : Effect [ object , Union [ ZeroDivisionError , ValueError ], int ] = f ( 0 ) Since Effect uses asyncio you should be careful not to create effects that block the main thread. Blocking happens in two ways: Performing IO Calling functions that take a long time to return To avoid blocking the main thread, synchronous IO should be performed in a separate thread, and CPU bound functions should be called in a separate process. pfun.effect handles this for you, but when creating your own effects you should take care to use api functions that run your cpu or io bound code in separate processes or threads. Functions for creating effects that run your function in other threads generally have io_bound in their name, and functions for creating effects that run your functions in other processes generally have cpu_bound in their name, for example lift_cpu_bound : import time from pfun.effect import lift_cpu_bound , success def slow_function ( a : int ) -> int : # simulate doing something slow time . sleep ( 2 ) return a + 2 lift_cpu_bound ( slow_function )( success ( 2 )) Take a look at the api documentation for details. Type Aliases Since the dependency type of Effect is often parameterized with object , and the error type is often parameterized with typing.NoReturn , a number of type aliases for Effect are provided to save you from typing out object and NoReturn over and over. Specifically: pfun.effect.Success[A] is a type-alias for Effect[object, typing.NoReturn, A] , which is useful for effects that can't fail and doesn't have dependencies pfun.effect.Try[E, A] is a type-alias for Effect[object, E, A] , which is useful for effects that can fail but doesn't have dependencies pfun.effect.Depends[R, A] is a type-alias for Effect[R, typing.NoReturn, A] which is useful for effects that can't fail but needs dependency R Combining effects Sometimes you need to keep the the result of two or more effects in scope to work with both at the same time. This can lead to code like the following: from pfun.effect import success two = success ( 2 ) four = two . and_then ( lambda a : lambda two . map ( lambda b : a + b )) In these cases, consider using pfun.effect.lift or pfun.effect.combine . lift is a decorator that enables any function to work with effects from pfun.effect import lift def add ( a : int , b : int ) -> int : return a + b four = lift ( add )( two , two ) combine is like lift but with its arguments flipped: from pfun.effect import combine four = combine ( two , two )( add )","title":"Effectful (But Side-Effect Free) Programming"},{"location":"effectful_but_side_effect_free/#maybe","text":"The job of the pfun.maybe.Maybe type is to help you work with missing values, in much the same way that the built-in None type is used. One of the main disadvantages of the None type is that you end up with logic for dealing with missing values all over the place, using code like if foo is not None . pfun.maybe.Maybe makes things a bit easier by generalising the if foo is not None part as a function called map . Imagine that you have function that looks up values in a dict and returns None if the key isn't found: from typing import Optional def lookup ( d : dict , key : str ) -> Optional [ str ]: try : return d [ key ] except KeyError : return None When using pfun.maybe to do the same thing, you will wrap the result of the lookup in a pfun.maybe.Just instance, and return a pfun.maybe.Nothing instance if the key wasn't found. In other words, it would look like this: from typing import Dict from pfun.maybe import Maybe , Just , Nothing def lookup ( d : Dict [ str , str ], key : str ) -> Maybe [ str ]: try : return Just ( d [ key ]) except KeyError : return Nothing () Now when using the lookup function, instead of checking if the return value is None everytime you call it, you can apply a function to the wrapped value if its not Nothing using map : lookup ({ 'key' : 'value' }, 'key' ) . map ( lambda v : f 'found { v } ' ) But what happens if you map a function that returns a new Just or Nothing ? e.g: def maybe_is_42 ( val : str ) -> Maybe [ str ]: if val == '42' : return Just ( val ) return Nothing () lookup ({ 'key' : '42' }, 'key' ) . map ( maybe_is_42 ) You end up with Just(Just(42)) ! Thats probably not what you wanted. When you want to apply a function that returns Just or Nothing , you should probably use and_then , which knows how to \"unwrap\" the result: lookup ({ 'key' : '42' }, 'key' ) . and_then ( maybe_is_42 ) # Just('42') (For those with previous functional programming experience, and_then is the bind operation of Maybe ) pfun.maybe.Maybe is in fact just a type-alias for Union[Just[TypeVar('A'), Nothing]] . This means that your type checker can figure out when you're dealing with one or the other using either __bool__ or isinstance , just like when using Optional : value = lookup ( some_dict , 'key' ) if value : ... # type checker knows that value is a Just else : ... # type checker knows that value is a Nothing","title":"Maybe"},{"location":"effectful_but_side_effect_free/#either","text":"One downside of the pfun.maybe.Maybe type is that it's not great for dealing with errors because pfun.maybe.Nothing can't provide any information about what went wrong. pfun.either.Either is a type that's used very similarly to Maybe , but unlike Maybe it can wrap an error value, as well as a success value. Just like when working with Maybe there are two types involved: pfun.either.Right and pfun.either.Left . The Right type is used to wrap successful results by convention. Left is used to wrap errors. Using the lookup function from before as an example, it would like this: from typing import Dict from pfun.either import Either , Right , Left def lookup ( d : Dict [ str , str ], key : str ) -> Either [ Exception , str ]: try : return Right ( d [ key ]) except KeyError as e : return Left ( e ) Just like with Maybe you can apply functions to values wrapped by Right using the map function, and you can transform results into new Either values with and_then : lookup ({ 'key' : 'value' }, 'key' ) . map ( lambda v : f 'found { v } !' ) def is_42 ( value : str ) -> Either [ str , str ]: return Right ( value ) if value == '42' else Left ( 'Wasn \\' t 42' ) lookup ({ 'key' : '42' }) . and_then ( is_42 ) # Right('42') Just like with Maybe , Either is actually a type-alias for Union[Left[TypeVar('L')], Right[TypeVar('R')]] , which allows the type-checker to narrow the type to one or the other using __bool__ or isinstance checks. value = lookup ( some_dict , 'key' ) if value : ... # type checker knows that value is a Right else : ... # type checker knows that value is a Left","title":"Either"},{"location":"effectful_but_side_effect_free/#effect","text":"The pfun.effect.Effect type lets you express side-effects in a side-effect free fashion. Readers with functional programming experience may be familiar with the term \" functional effect system \", which is precisely what pfun.effect.Effect is. The core type you will use when expressing side-effects with pfun is pfun.effect.Effect . Effect has a function run that perfoms the side-effect it represents. run is a function that: Takes exactly one argument May or may not perform side-effects when called (including raising exceptions) You can think of Effect defined as: from typing import TypeVar , Generic from pfun.either import Either R = TypeVar ( 'R' , contravariant = True ) E = TypeVar ( 'E' , covariant = True ) A = TypeVar ( 'A' , covariant = True ) class Effect ( Generic [ R , E , A ]): def run ( self , r : R ) -> A : \"\"\" May raise E \"\"\" ... In other words, Effect takes three type paramaters: R , E and A . We'll study them one at a time.","title":"Effect"},{"location":"effectful_but_side_effect_free/#the-success-type","text":"The A in Effect[R, E, A] is the success type . This is the type that the effect function will return if no error occurs. For example, in an Effect instance that reads a file as a str , A would be parameterized with str . You can create an Effect instance that succeeds with the value a using pfun.effect.success(a) : from typing import NoReturn from pfun.effect import success , Effect e : Effect [ object , NoReturn , str ] = success ( 'Success!' ) assert e . run ( None ) == 'Success!' (You don't actually have to write the type of e explicitly, as it can be inferred by your type checker. We do it here simply because it's instructive to look at the types). Don't worry about the meaning of object and NoReturn for now, we'll explain that later. For now, just understand that when e has the type Effect[object, NoReturn, str] , it means that when you call e.run with any parameter, it will return a str (the value Success! ). You can work with the success value of an effect using instance methods of Effect . If you want to transform the result of an Effect with a function without side-effects you can use map , which takes a function of the type Callable[[A], B] as an argument, where A is the success type of your effect: e : Effect [ object , NoReturn , str ] = success ( 1 ) . map ( str ) assert e . run ( None ) == \"1\" If you want to transform the result of an Effect with a function that produces other side effects (that is, returns an Effect instance), you use and_then : add_1 = lambda v : success ( v + 1 ) e : Effect [ object , NoReturn , int ] = success ( 1 ) . and_then ( add_1 ) assert e . run ( None ) == 2 (for those with previous functional programming experince, and_then is the \" bind \" operation of Effect ).","title":"The Success Type"},{"location":"effectful_but_side_effect_free/#the-error-type","text":"The E in Effect[R, E, A] is the error type . This is type that the run function will raise if it fails. You can create an effect that does nothing but fail using pfun.effect.error : from typing import NoReturn from pfun.effect import Effect , error e : Effect [ object , str , NoReturn ] = error ( 'Whoops!' ) e . run ( None ) # raises: RuntimeError('Whoops!') For a concrete example, take a look at the pfun.files module that helps you read from files: from pfun.effect import Effect from pfun.files import Files files = Files () e : Effect [ object , OSError , str ] = files . read ( 'doesnt_exist.txt' ) e . run ( None ) # raises OSError Don't worry about the api of files for now, simply notice that when e has the type Effect[object, OSError, str] , it means that when you execute e it can produce a str or fail with OSError . Having the the error type explicitly modelled in the type signature of e allows type safe error handling as we'll see later.","title":"The Error Type"},{"location":"effectful_but_side_effect_free/#the-dependency-type","text":"Finally, let's look at R in Effect[R, E, A] : the dependency type . R is the argument that run requires to produce its result. It allows you to parameterize the side-effect that your Effect implements which improves re-useability and testability. For example, imagine that you want to use Effect to model the side-effect of reading from a database. The function that reads from the database requires a connection string as an argument to connect. If Effect did not take a parameter you would have to pass around the connection string as a parameter through function calls, all the way down to where the connection string was needed. The dependency type allows you to pass in the connection string at the edge of your program, rather than threading it through a potentially deep stack of function calls: from typing import List , Dict , Any DBRow = Dict [ Any , Any ] def execute ( query : str ) -> Effect [ str , IOError , List [ DBRow ]]: ... def find_row ( results : List [ DBRow ]) -> DBRow : ... def main () -> Effect [ str , IOError , DBRow ]: return execute ( 'select * from users;' ) . map ( find_row ) if __name__ == '__main__' : program = main () # run in production program . run ( 'user@prod_db' ) # run in development program . run ( 'user@dev_db' ) In the next section, we will discuss this dependency injection capability of Effect in detail.","title":"The Dependency Type"},{"location":"effectful_but_side_effect_free/#the-module-pattern","text":"This section is dedicated to the dependency type R . In most examples we have looked at so far, R is parameterized with object . This means that it can safely be called with any value (since all Python values are sub-types of object ). This is mostly useful when you're working with effects that don't use the dependency argument for anything, in which case any value will do. In the previous section we saw how the R parameter of Effect can be used for dependency injection. But what happens when we try to combine two effects with different dependency types with and_then ? The Effect instance returned by and_then must have a dependency type that is a combination of the dependency types of both the combined effects, since the dependency passed to the combined effect is also passed to the other effects. Consider for example this effect, that uses the execute function from above to get database results, and combines it with a function make_request that calls an api, and requires a Credentials instance as the dependency type: class Credentials : ... def make_request ( results : List [ DBRow ]) -> Effect [ Credentials , HTTPError , bytes ]: ... results : effect . Effect [ str , IOError , List [ DBRow ]] = execute ( 'select * from users;' ) response : effect . Effect [ ... , Union [ IOError , HTTPError ], HTTPResponse ] response = results . and_then ( make_request ) response . run ( ... ) # What could this argument be? To call the response.run function, we need an instance of a type that is a str and a Credentials instance at the same time , because that argument must be passed to both the effect returned by execute and by make_request . Ideally, we want response to have the type Effect[Intersection[Credentials, str], IOError, bytes] , where Intersection[Credentials, str] indicates that the dependency type must be both of type Credentials and of type str . In theory such an object could exist (defined as class MyEnv(Credentials, str): ... ), but there are no straight-forward way of expressing that type dynamically in the Python type system. As a consequence, pfun infers the resulting effect with the R parameterized as typing.Any , which in this case means that pfun could not assign a meaningful type to R . If you use the pfun MyPy plugin, you can however redesign the program to follow a pattern that enables pfun to infer a meaningful combined type in much the same way that the error type resulting from combining two effects using and_then can be inferred. This pattern is called the module pattern . In its most basic form, the module pattern simply involves defining a Protocol that serves as the dependency type of an Effect . pfun can combine dependency types of two effects whose dependency types are both protocols, because the combined dependency type is simply a new protocol that inherits from both. This combined protocol is called pfun.Intersection . In many cases the api for effects involved in the module pattern is split into three parts: A module class that provides the actual implementation A module provider that is a typing.Protocol that provides the module class as an attribute Functions that return effects with the module provider class as the dependency type. Lets rewrite our example from before to follow the module pattern: from typing import Protocol from http.client import HTTPError from pfun.effect import Effect , depend class Requests : \"\"\" Requests implementation module \"\"\" def __init__ ( self , credentials : Credentials ): self . credentials = credentials def make_request ( self , results : List [ DBRow ]) -> Effect [ object , HTTPError , bytes ]: ... class HasRequests ( Protocol ): \"\"\" Module provider class for the requests module \"\"\" requests : Requests def make_request ( results : List [ DBRow ]) -> Effect [ HasRequests , HTTPError , bytes ]: \"\"\" Function that returns an effect with the HasRequest module provider as the dependency type \"\"\" return depend ( HasRequests ) . and_then ( lambda env : env . requests . make_request ( results )) class Database : \"\"\" Database implementation module \"\"\" def __init__ ( self , connection_str : str ): self . connection_str = connection_str def execute ( self , query : str ) -> Effect [ object , IOError , List [ DBRow ]]: ... class HasDatabase ( Protocol ): \"\"\" Module provider class for the database module \"\"\" database : Database def execute ( query : str ) -> Effect [ HasDatabase , IOError , List [ DBRow ]]: \"\"\" Function that returns an effect with the HasDatabase module provider as the dependency type \"\"\" return depend ( HasDatabase ) . and_then ( lambda env : env . database . execute ( query )) There are two modules : Requests and Database that provide implementations. There are two corresponding module providers : HasRequests and HasDatabase . Finally there are two functions execute and make_request that puts it all together. Pay attention to the fact that execute and make_request look quite similar: they both start by calling pfun.effect.depend . This function returns an effect that succeeds with the dependency value that will eventually be passed as the argument to the final effect (in this example the effect produced by execute(...).and_then(make_request) ). The optional parameter passed to depend is merely for type-checking purposes, and doesn't change the result in any way. If we combine the new functions execute and make_request that both has protocols as the dependency types, pfun can infer a meaningful type, and make sure that the dependency type that is eventually passed to the whole program provides both the requests and the database attributes: effect = execute ( 'select * from users;' ) . and_then ( make_request ) The type of effect in this case will be Effect [ pfun . Intersection [ HasRequests , HasDatabase ], Union [ HTTPError , IOError ], bytes ] Quite a mouthful, but what it tells us is that effect must be run with an instance of a type that has both the requests and database attributes with appropriate types. In other words, if you accidentally defined your dependency as: class Env : database = Database ( 'user@prod_db' ) effect . run ( Env ()) MyPy would tell you the call effect.run(Env()) is a type error since Env doesn't have a requests attribute. It's worth understanding the module pattern, since pfun uses it pervasively in its api, e.g in pfun.files and pfun.console , in order that pfun can infer the dependency type of effects resulting from combining functions from pfun with user defined functions that also follow the module pattern. A very attractive added bonus of the module pattern is that mocking out particular dependencies of your program becomes extremely simple, and by extension that unit testing becomes easier: from pfun.effect import success from unittest.mock import Mock mock_env = Mock () mock_env . requests . make_request . return_value = success ( b 'Mocked!' ) assert make_request ([])( mock_env ) == b 'Mocked!'","title":"The Module Pattern"},{"location":"effectful_but_side_effect_free/#error-handling","text":"In this section, we'll look at how to handle errors of effects with type safety. In previous sections we have already spent some time looking at the Effect error type. In many of the examples so far, the error type was typing.NoReturn . An Effect with this error type can never return a value for an error, or in other words, it can never fail (as those effects returned by pfun.effect.success ). In the rest of this section we'll of course be pre-occupied with effects that can fail. When you combine side effects using Effect.and_then , pfun uses typing.Union to combine error types, in order that the resulting effect captures all potential errors in its error type: from typing import List from pfun.files import Files def parse ( content : str ) -> effect . Effect [ object , ZeroDivisionError , List [ int ]]: ... files = Files () e : Effect [ object , Union [ OSError , ZeroDivisionError ], List [ int ]] e = files . read ( 'foo.txt' ) . and_then ( parse ) e has Union[OSError, ZeroDivisionError] as its error type because it can fail if files.read fails, or if parse fails. This compositional aspect of the error type of Effect means that accurate and complex error types are built up from combining simple error types. Moreover, it makes reasoning about error handling easy because errors disappear from the type when they are handled, as we shall see next. The most low level function you can use to handle errors is Effect.either , which surfaces any errors that may have occurred as a pfun.either.Either , where a pfun.either.Right signifies a successful computation and a pfun.either.Left a failed computation: from typing import NoReturn from pfun.effect import Effect , files from pfun.either import Either , Left # files.read can fail with OSError may_have_failed : Effect [ files . HasFiles , OSError , str ] = files . read ( 'foo.txt' ) # calling either() surfaces the OSError in the success type as a pfun.either.Either as_either : Effect [ files . HasFiles , NoReturn , Either [ OSError , str ]] = may_have_failed . either () # we can use map or and_then to handle the error cant_fail : Effect [ files . HasFiles , NoReturn , str ] = as_either . map ( lambda either : 'backup content' if isinstance ( either , Left ) else either . get ) Once you've handled whatever errors you want, you can push the error back into error type of the effect using pfun.effect.absolve : from typing import NoReturn , List from pfun.effect import Effect , absolve , files from pfun.either import Either # function to handle error def handle ( either : Either [ Union [ OSError , ZeroDivisionError ], str ]) -> Either [ ZeroDivisionError , str ]: ... # define an effect that can fail e : Effect [ object , Union [ OSError , ZeroDivisionError ], List [ int ]] = files . read ( 'foo.txt' ) . and_then ( parse ) # handle errors using e.either.map without_os_error : Effect [ object , NoReturn , Either [ OSError , str ]] = e . either () . map ( handle ) # push the remaining error into the error type using absolve e2 : Effect [ object , OSError , str ] = absolve ( without_os_error ) At a slightly higher level, you can use Effect.recover , which takes a function that can inspect the error and handle it. from typing import Union from pfun.effect import success , error , Effect def handle_errors ( reason : Union [ OSError , ZeroDivisionError ]) -> Effect [ object , ZeroDivisionError , str ]: if isinstance ( reason , OSError ): return success ( 'default value' ) return error ( reason ) recovered : Effect [ object , ZeroDivisionError , str ] = e . recover ( handle_errors ) You will frequently handle errors by using isinstance to compare errors with types, so defining your own error types becomes even more important when using pfun to distinguish one error source from another.","title":"Error Handling"},{"location":"effectful_but_side_effect_free/#concurrency","text":"Effect uses asyncio under the hood to run effects asynchronously. This can lead to significant speed ups. Consider for example this program that calls curl http://www.google.com in a subprocess 50 times: # call_google_sync.py import timeit import subprocess [ subprocess . run ([ 'curl' , 'http://www.google.com' ]) for _ in range ( 50 )] Timing the execution using the unix time informs me this takes 5.15 seconds on a normal consumer laptop. Compare this to the program below which does more or less the same thing, but using pfun.subprocess : # call_google_async.py from pfun.subprocess import Subprocess from pfun.effect import sequence_async sp = Subprocess () effect = sequence_async ( sp . run_in_shell ( 'curl http://www.google.com' ) for _ in range ( 50 ) effect . run ( None ) This program finishes in 0.78 seconds, according to time . The crucial difference is the function pfun.effect.sequence_async which returns a new effect that runs its argument effects asynchronously using asyncio . This means that one effect can yield to other effects while waiting for input from the curl subprocess. This ultimately saves a lot of time compared to the synchronous implementation where each call to subprocess.run can only start when the preceeding one has returned. You can create an effect from a Python awaitable using pfun.effect.from_awaitable , allowing you to integrate with asyncio directly in your own code: import asyncio from typing import NoReturn from pfun.effect import from_awaitable , Effect async def sleep () -> str : await asyncio . sleep ( 1 ) return 'success!' e : Effect [ object , NoReturn , str ] = from_awaitable ( sleep ()) assert e . run ( None ) == 'success!' You can also pass async functions directly to map and and_then : from typing import NoReturn import asyncio from pfun.effect import success async def sleep_and_add_1 ( a : int ) -> int : await asyncio . sleep ( 1 ) return a + 1 assert success ( 1 ) . map ( sleep_and_add_1 ) . run ( None ) == 2 When using pfun with async frameworks such as ASGI web servers , you can await the the result of effects using Effect.__call__ (which is really what Effect.run calls using the supplied event-loop): async def f () -> str : e : Effect [ object , NoReturn , str ] = ... return await e ( None )","title":"Concurrency"},{"location":"effectful_but_side_effect_free/#purely-functional-state","text":"Mutating non-local state is a side-effect that we want to avoid when doing functional programming. This means that we need a mechanism for managing state as an effect. pfun.ref provides exactly this. pfun.ref works by mutating state only by calling Effect instances. from typing import Tuple , NoReturn from pfun.ref import Ref from pfun.effect import Effect ref : Ref [ Tuple [ int , ... ]] = Ref (()) add_1 : Effect [ object , NoReturn , None ] = ref . modify ( lambda old : return old + ( 1 ,)) # calling modify doesn't modify the state directly assert ref . value == () # The state is modified only when the effect is called add_1 . run ( None ) assert ref . value == ( 1 ,) pfun.ref.Ref protects access to the state using an asyncio.Lock , meaning that updating the state can be done atomically with the following methods: Ref.get() read the current value of the state Ref.set(new_state) update the state to new_value atomically, meaning no other effect can read the value of the state while the update is in progress. Note that if you first read the state using Ref.get and then set it with Ref.set , other effects may read the value in between which may lead to lost updates. For this use case you should use modify or try_modify Ref.modify(update_function) read and update the state with update_function atomically, meaning no other effect can read or write the state before the effect produced by modify returns Ref.try_modify(update_function) read and update the state with update_function atomically, if update_funciton succeeds. Success is signaled by the update_function by returning a pfun.either.Right instance, and error by returning a pfun.either.Left instance. pfun.ref can of course be combined with the module pattern: from typing import Tuple , NoReturn , Protocol from pfun.ref import Ref from pfun.effect import depend , Effect class HasState ( Protocol ): state : Ref [ Tuple [ int , ... ]] def set_state ( state : Tuple [ int , ... ]) -> Effect [ HasState , NoReturn , None ]: return depend () . and_then ( lambda env . state . set ( state ))","title":"Purely Functional State"},{"location":"effectful_but_side_effect_free/#creating-your-own-effects","text":"pfun.effect has a number of decorators and helper functions to help you create your own effects. pfun.effect.from_callable is the most flexible option. It takes a function that takes a dependency type and returns a pfun.either.Either and turns it into an effect: from pfun.effect import from_callable , Effect from pfun.either import Either def f ( r : str ) -> Either [ Exception , float ]: ... effect : Effect [ str , Exception , float ] = from_callable ( f ) from_callable may also be used to create effects from async functions: import asyncio async def f ( r : str ) -> Either [ Exception , float ]: await asyncio . sleep ( 1 ) ... effect : Effect [ str , Exception , float ] = from_callable ( f ) pfun.effect.catch is used to decorate sync and async functions that may raise exceptions. If the decorated function performs side effects, they are not carried out until the effect is run from pfun.effect import catch , Effect @catch ( ZeroDivisionError , ValueError ) def f ( v : int ) -> int : if v > 5 : raise ValueError ( 'v is not allowed to be > 5 for some reason' ) return 1 / v effect : Effect [ object , Union [ ZeroDivisionError , ValueError ], int ] = f ( 0 ) Since Effect uses asyncio you should be careful not to create effects that block the main thread. Blocking happens in two ways: Performing IO Calling functions that take a long time to return To avoid blocking the main thread, synchronous IO should be performed in a separate thread, and CPU bound functions should be called in a separate process. pfun.effect handles this for you, but when creating your own effects you should take care to use api functions that run your cpu or io bound code in separate processes or threads. Functions for creating effects that run your function in other threads generally have io_bound in their name, and functions for creating effects that run your functions in other processes generally have cpu_bound in their name, for example lift_cpu_bound : import time from pfun.effect import lift_cpu_bound , success def slow_function ( a : int ) -> int : # simulate doing something slow time . sleep ( 2 ) return a + 2 lift_cpu_bound ( slow_function )( success ( 2 )) Take a look at the api documentation for details.","title":"Creating Your Own Effects"},{"location":"effectful_but_side_effect_free/#type-aliases","text":"Since the dependency type of Effect is often parameterized with object , and the error type is often parameterized with typing.NoReturn , a number of type aliases for Effect are provided to save you from typing out object and NoReturn over and over. Specifically: pfun.effect.Success[A] is a type-alias for Effect[object, typing.NoReturn, A] , which is useful for effects that can't fail and doesn't have dependencies pfun.effect.Try[E, A] is a type-alias for Effect[object, E, A] , which is useful for effects that can fail but doesn't have dependencies pfun.effect.Depends[R, A] is a type-alias for Effect[R, typing.NoReturn, A] which is useful for effects that can't fail but needs dependency R","title":"Type Aliases"},{"location":"effectful_but_side_effect_free/#combining-effects","text":"Sometimes you need to keep the the result of two or more effects in scope to work with both at the same time. This can lead to code like the following: from pfun.effect import success two = success ( 2 ) four = two . and_then ( lambda a : lambda two . map ( lambda b : a + b )) In these cases, consider using pfun.effect.lift or pfun.effect.combine . lift is a decorator that enables any function to work with effects from pfun.effect import lift def add ( a : int , b : int ) -> int : return a + b four = lift ( add )( two , two ) combine is like lift but with its arguments flipped: from pfun.effect import combine four = combine ( two , two )( add )","title":"Combining effects"},{"location":"either_api/","text":"pfun . either . Either Type-alias for Union[Left[TypeVar('L')], Right[TypeVar('R')]] pfun.either.Left dataclass Represents the Left case of Either get : + B dataclass-field The left result __eq__ ( self , other ) Test if other is an Left wrapping the same value as this instance Examples: >>> Left ( 'error message' ) == Left ( 'error message' ) True >>> Left ( 'error message' ) == Left ( 'another message' ) False Parameters: Name Type Description Default other object object to compare with required Returns: Type Description bool True if other is an Left instance and wraps the same value as this instance, False otherwise and_then ( self , f ) Chain together functions of either computations, keeping track of whether or not any of them have failed Examples: >>> f = lambda i : Right ( 1 / i ) if i != 0 else Left ( 'i was 0' ) >>> Right ( 1 ) . and_then ( f ) Right ( 1.0 ) >>> Right ( 0 ) . and_then ( f ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], Either[B, C]] The function to call required Returns: Type Description Either[B, C] Right of type A if the computation was successful, Left of type B otherwise. map ( self , f ) Map the result of this either computation Examples: >>> f = ( lambda i : Right ( 1 / i ) ... if i != 0 else Left ( 'i was 0' ) . map ( str )) >>> Right ( 1 ) . and_then ( f ) . map ( str ) Right ( '0.5' ) >>> Ok ( 0 ) . and_then ( f ) . map ( str ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], C] Function to apply to the result required Returns: Type Description Either[B, C] Right wrapping result of type C if the computation was if this is a Right value, Left of type B otherwise or_else ( self , default ) Try to get the result of this either computation, return default if this is a Left value Examples: >>> Right ( 1 ) . or_else ( 2 ) 1 >>> Left ( 1 ) . or_else ( 2 ) 2 Parameters: Name Type Description Default default C Value to return if this is a Left value required Returns: Type Description C Result of computation if this is a Right value, default otherwise pfun.either.Right dataclass Represents the Right case of Either get : + A dataclass-field The right result __eq__ ( self , other ) Test if other is a Right wrapping the same value as this instance Examples: >>> Right ( 'value' ) == Right ( 'value' ) True >>> Right ( 'another value' ) == Right ( 'value' ) False Parameters: Name Type Description Default other Any object to compare with required Returns: Type Description bool True if other is a Right instance and wraps the same value as this instance, False otherwise and_then ( self , f ) Chain together functions of either computations, keeping track of whether or not any of them have failed Examples: >>> f = lambda i : Right ( 1 / i ) if i != 0 else Left ( 'i was 0' ) >>> Right ( 1 ) . and_then ( f ) Right ( 1.0 ) >>> Right ( 0 ) . and_then ( f ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], Either[B, C]] The function to call required Returns: Type Description Either[B, C] Right of type A if the computation was successful, Left of type B otherwise. map ( self , f ) Map the result of this either computation Examples: >>> f = ( lambda i : Right ( 1 / i ) ... if i != 0 else Left ( 'i was 0' ) . map ( str )) >>> Right ( 1 ) . and_then ( f ) . map ( str ) Right ( '0.5' ) >>> Ok ( 0 ) . and_then ( f ) . map ( str ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], C] Function to apply to the result required Returns: Type Description Either[Any, C] Right wrapping result of type C if the computation was if this is a Right value, Left of type B otherwise or_else ( self , default ) Try to get the result of this either computation, return default if this is a Left value Examples: >>> Right ( 1 ) . or_else ( 2 ) 1 >>> Left ( 1 ) . or_else ( 2 ) 2 Parameters: Name Type Description Default default C Value to return if this is a Left value required Returns: Type Description A Result of computation if this is a Right value, default otherwise pfun . either . either ( f ) Turn f into a monadic function in the Either monad by wrapping in it a Right Examples: >>> either ( lambda v : v )( 1 ) Right ( 1 ) Parameters: Name Type Description Default f Callable[..., A] function to wrap required Returns: Type Description Callable[..., Either[A, B]] f wrapped with a Right pfun . either . for_each ( f , iterable ) Map each in element in iterable to an Either by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( Right , range ( 3 )) Right (( 0 , 1 , 2 )) Parameters: Name Type Description Default f Callable[[A], Either[B, C]] Function to map over iterable required iterable Iterable[A] Iterable to map f over required Returns: Type Description Either[B, Iterable[C]] f mapped over iterable and combined from left to right. pfun . either . sequence ( iterable ) Evaluate each Either in iterable from left to right and collect the results Examples: >>> sequence ([ Right ( v ) for v in range ( 3 )]) Right (( 0 , 1 , 2 )) Parameters: Name Type Description Default iterable Iterable[Either[A, B]] The iterable to collect results from required Returns: Type Description Either[A, Iterable[B]] Either of collected results pfun . either . filter_ ( f , iterable ) Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : Right ( v % 2 == 0 ), range ( 3 )) Right (( 0 , 2 )) Parameters: Name Type Description Default f Callable[[A], Either[B, bool]] Function to map iterable by required iterable Iterable[A] Iterable to map by f required Returns: Type Description Either[B, Iterable[A]] iterable mapped and filtered by f pfun . either . catch ( f ) Decorator that wraps return values of decoratod functions with Right , and wraps catched exceptions with Left Examples: >>> catch_division = catch ( lambda v : 1 / v ) >>> catch_division ( 1 ) Right ( 1.0 ) >>> catch_division ( 0 ) Left ( ZeroDivisionError ( 'division by zero' )) Parameters: Name Type Description Default f Callable[..., A] function to decorate required Returns: Type Description Callable[..., Either[Exception, A]] decorated function","title":"pfun.either"},{"location":"either_api/#pfun.either.Either","text":"Type-alias for Union[Left[TypeVar('L')], Right[TypeVar('R')]]","title":"Either"},{"location":"either_api/#pfun.either.Left","text":"Represents the Left case of Either","title":"Left"},{"location":"either_api/#pfun.either.Left.get","text":"The left result","title":"get"},{"location":"either_api/#pfun.either.Left.__eq__","text":"Test if other is an Left wrapping the same value as this instance Examples: >>> Left ( 'error message' ) == Left ( 'error message' ) True >>> Left ( 'error message' ) == Left ( 'another message' ) False Parameters: Name Type Description Default other object object to compare with required Returns: Type Description bool True if other is an Left instance and wraps the same value as this instance, False otherwise","title":"__eq__()"},{"location":"either_api/#pfun.either.Left.and_then","text":"Chain together functions of either computations, keeping track of whether or not any of them have failed Examples: >>> f = lambda i : Right ( 1 / i ) if i != 0 else Left ( 'i was 0' ) >>> Right ( 1 ) . and_then ( f ) Right ( 1.0 ) >>> Right ( 0 ) . and_then ( f ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], Either[B, C]] The function to call required Returns: Type Description Either[B, C] Right of type A if the computation was successful, Left of type B otherwise.","title":"and_then()"},{"location":"either_api/#pfun.either.Left.map","text":"Map the result of this either computation Examples: >>> f = ( lambda i : Right ( 1 / i ) ... if i != 0 else Left ( 'i was 0' ) . map ( str )) >>> Right ( 1 ) . and_then ( f ) . map ( str ) Right ( '0.5' ) >>> Ok ( 0 ) . and_then ( f ) . map ( str ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], C] Function to apply to the result required Returns: Type Description Either[B, C] Right wrapping result of type C if the computation was if this is a Right value, Left of type B otherwise","title":"map()"},{"location":"either_api/#pfun.either.Left.or_else","text":"Try to get the result of this either computation, return default if this is a Left value Examples: >>> Right ( 1 ) . or_else ( 2 ) 1 >>> Left ( 1 ) . or_else ( 2 ) 2 Parameters: Name Type Description Default default C Value to return if this is a Left value required Returns: Type Description C Result of computation if this is a Right value, default otherwise","title":"or_else()"},{"location":"either_api/#pfun.either.Right","text":"Represents the Right case of Either","title":"Right"},{"location":"either_api/#pfun.either.Right.get","text":"The right result","title":"get"},{"location":"either_api/#pfun.either.Right.__eq__","text":"Test if other is a Right wrapping the same value as this instance Examples: >>> Right ( 'value' ) == Right ( 'value' ) True >>> Right ( 'another value' ) == Right ( 'value' ) False Parameters: Name Type Description Default other Any object to compare with required Returns: Type Description bool True if other is a Right instance and wraps the same value as this instance, False otherwise","title":"__eq__()"},{"location":"either_api/#pfun.either.Right.and_then","text":"Chain together functions of either computations, keeping track of whether or not any of them have failed Examples: >>> f = lambda i : Right ( 1 / i ) if i != 0 else Left ( 'i was 0' ) >>> Right ( 1 ) . and_then ( f ) Right ( 1.0 ) >>> Right ( 0 ) . and_then ( f ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], Either[B, C]] The function to call required Returns: Type Description Either[B, C] Right of type A if the computation was successful, Left of type B otherwise.","title":"and_then()"},{"location":"either_api/#pfun.either.Right.map","text":"Map the result of this either computation Examples: >>> f = ( lambda i : Right ( 1 / i ) ... if i != 0 else Left ( 'i was 0' ) . map ( str )) >>> Right ( 1 ) . and_then ( f ) . map ( str ) Right ( '0.5' ) >>> Ok ( 0 ) . and_then ( f ) . map ( str ) Left ( 'i was 0' ) Parameters: Name Type Description Default f Callable[[A], C] Function to apply to the result required Returns: Type Description Either[Any, C] Right wrapping result of type C if the computation was if this is a Right value, Left of type B otherwise","title":"map()"},{"location":"either_api/#pfun.either.Right.or_else","text":"Try to get the result of this either computation, return default if this is a Left value Examples: >>> Right ( 1 ) . or_else ( 2 ) 1 >>> Left ( 1 ) . or_else ( 2 ) 2 Parameters: Name Type Description Default default C Value to return if this is a Left value required Returns: Type Description A Result of computation if this is a Right value, default otherwise","title":"or_else()"},{"location":"either_api/#pfun.either.either","text":"Turn f into a monadic function in the Either monad by wrapping in it a Right Examples: >>> either ( lambda v : v )( 1 ) Right ( 1 ) Parameters: Name Type Description Default f Callable[..., A] function to wrap required Returns: Type Description Callable[..., Either[A, B]] f wrapped with a Right","title":"either()"},{"location":"either_api/#pfun.either.for_each","text":"Map each in element in iterable to an Either by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( Right , range ( 3 )) Right (( 0 , 1 , 2 )) Parameters: Name Type Description Default f Callable[[A], Either[B, C]] Function to map over iterable required iterable Iterable[A] Iterable to map f over required Returns: Type Description Either[B, Iterable[C]] f mapped over iterable and combined from left to right.","title":"for_each()"},{"location":"either_api/#pfun.either.sequence","text":"Evaluate each Either in iterable from left to right and collect the results Examples: >>> sequence ([ Right ( v ) for v in range ( 3 )]) Right (( 0 , 1 , 2 )) Parameters: Name Type Description Default iterable Iterable[Either[A, B]] The iterable to collect results from required Returns: Type Description Either[A, Iterable[B]] Either of collected results","title":"sequence()"},{"location":"either_api/#pfun.either.filter_","text":"Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : Right ( v % 2 == 0 ), range ( 3 )) Right (( 0 , 2 )) Parameters: Name Type Description Default f Callable[[A], Either[B, bool]] Function to map iterable by required iterable Iterable[A] Iterable to map by f required Returns: Type Description Either[B, Iterable[A]] iterable mapped and filtered by f","title":"filter_()"},{"location":"either_api/#pfun.either.catch","text":"Decorator that wraps return values of decoratod functions with Right , and wraps catched exceptions with Left Examples: >>> catch_division = catch ( lambda v : 1 / v ) >>> catch_division ( 1 ) Right ( 1.0 ) >>> catch_division ( 0 ) Left ( ZeroDivisionError ( 'division by zero' )) Parameters: Name Type Description Default f Callable[..., A] function to decorate required Returns: Type Description Callable[..., Either[Exception, A]] decorated function","title":"catch()"},{"location":"files_api/","text":"pfun.files.Files dataclass Module that enables reading and writing from files append ( self , path , content ) Get an Effect that appends to a file Examples: >>> files = Files () >>> files \\ ... . append ( 'foo.txt' , 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that appends content to file at path append_bytes ( self , path , content ) Get an Effect that appends to a file Examples: >>> files = Files () >>> files \\ ... . append_bytes ( 'foo.txt' , b 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that appends content to file at path read ( self , path ) get an Effect that reads the content of a file as a str Examples: >>> Files () . read ( 'foo.txt' ) . run ( None ) 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Try[OSError, str] Effect that reads file located at path read_bytes ( self , path ) get an Effect that reads the content of a file as bytes Examples: >>> Files () . read_bytes ( 'foo.txt' ) . run ( None ) b 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Try[OSError, bytes] Effect that reads file located at path write ( self , path , content ) Get an Effect that writes to a file Examples: >>> files = Files () >>> files \\ ... . write ( 'foo.txt' , 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that writes content to file at path write_bytes ( self , path , content ) Get an Effect that writes to a file Examples: >>> files = Files () >>> files \\ ... . write_bytes ( 'foo.txt' , b 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that writes content to file at path pfun.files.HasFiles Module provider that provides the files module :attribute files: The Files instance pfun . files . read ( path ) get an Effect that reads the content of a file as a str Examples: >>> class Env : ... files = Files () >>> read ( 'foo.txt' ) . run ( Env ()) 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Effect[HasFiles, OSError, str] Effect that reads file located at path pfun . files . read_bytes ( path ) get an Effect that reads the content of a file as bytes Examples: >>> class Env : ... files = Files () >>> read_bytes ( 'foo.txt' ) . run ( Env ()) b 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Effect[HasFiles, OSError, bytes] Effect that reads file located at path pfun . files . write ( path , content ) Get an Effect that writes to a file Examples: >>> class Env : ... files = Files () >>> write ( 'foo.txt' )( 'contents' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that writes content to file at path pfun . files . write_bytes ( path , content ) Get an Effect that writes to a file Examples: >>> class Env : ... files = Files () >>> write_bytes ( 'foo.txt' )( b 'content of foo.txt' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that writes content to file at path pfun . files . append ( path , content ) Get an Effect that appends to a file Examples: >>> class Env : ... files = Files () >>> append ( 'foo.txt' )( 'content of foo.txt' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that appends content to file at path pfun . files . append_bytes ( path , content ) Get an Effect that appends to a file Examples: >>> class Env : ... files = Files () >>> append_bytes ( 'foo.txt' )( b 'content of foo.txt' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that appends content to file at path","title":"pfun.files"},{"location":"files_api/#pfun.files.Files","text":"Module that enables reading and writing from files","title":"Files"},{"location":"files_api/#pfun.files.Files.append","text":"Get an Effect that appends to a file Examples: >>> files = Files () >>> files \\ ... . append ( 'foo.txt' , 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that appends content to file at path","title":"append()"},{"location":"files_api/#pfun.files.Files.append_bytes","text":"Get an Effect that appends to a file Examples: >>> files = Files () >>> files \\ ... . append_bytes ( 'foo.txt' , b 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that appends content to file at path","title":"append_bytes()"},{"location":"files_api/#pfun.files.Files.read","text":"get an Effect that reads the content of a file as a str Examples: >>> Files () . read ( 'foo.txt' ) . run ( None ) 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Try[OSError, str] Effect that reads file located at path","title":"read()"},{"location":"files_api/#pfun.files.Files.read_bytes","text":"get an Effect that reads the content of a file as bytes Examples: >>> Files () . read_bytes ( 'foo.txt' ) . run ( None ) b 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Try[OSError, bytes] Effect that reads file located at path","title":"read_bytes()"},{"location":"files_api/#pfun.files.Files.write","text":"Get an Effect that writes to a file Examples: >>> files = Files () >>> files \\ ... . write ( 'foo.txt' , 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that writes content to file at path","title":"write()"},{"location":"files_api/#pfun.files.Files.write_bytes","text":"Get an Effect that writes to a file Examples: >>> files = Files () >>> files \\ ... . write_bytes ( 'foo.txt' , b 'contents' ) \\ ... . discard_and_then ( files . read ( 'foo.txt' )) \\ ... . run ( None ) 'contents' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Try[OSError, None] Effect that that writes content to file at path","title":"write_bytes()"},{"location":"files_api/#pfun.files.HasFiles","text":"Module provider that provides the files module :attribute files: The Files instance","title":"HasFiles"},{"location":"files_api/#pfun.files.read","text":"get an Effect that reads the content of a file as a str Examples: >>> class Env : ... files = Files () >>> read ( 'foo.txt' ) . run ( Env ()) 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Effect[HasFiles, OSError, str] Effect that reads file located at path","title":"read()"},{"location":"files_api/#pfun.files.read_bytes","text":"get an Effect that reads the content of a file as bytes Examples: >>> class Env : ... files = Files () >>> read_bytes ( 'foo.txt' ) . run ( Env ()) b 'contents of foo.txt' Parameters: Name Type Description Default path str path to file required Returns: Type Description Effect[HasFiles, OSError, bytes] Effect that reads file located at path","title":"read_bytes()"},{"location":"files_api/#pfun.files.write","text":"Get an Effect that writes to a file Examples: >>> class Env : ... files = Files () >>> write ( 'foo.txt' )( 'contents' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that writes content to file at path","title":"write()"},{"location":"files_api/#pfun.files.write_bytes","text":"Get an Effect that writes to a file Examples: >>> class Env : ... files = Files () >>> write_bytes ( 'foo.txt' )( b 'content of foo.txt' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that writes content to file at path","title":"write_bytes()"},{"location":"files_api/#pfun.files.append","text":"Get an Effect that appends to a file Examples: >>> class Env : ... files = Files () >>> append ( 'foo.txt' )( 'content of foo.txt' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that appends content to file at path","title":"append()"},{"location":"files_api/#pfun.files.append_bytes","text":"Get an Effect that appends to a file Examples: >>> class Env : ... files = Files () >>> append_bytes ( 'foo.txt' )( b 'content of foo.txt' ) \\ ... . discard_and_then ( read ( 'foo.txt' )) \\ ... . run ( Env ()) 'content of foo.txt' Parameters: Name Type Description Default path str the path of the file to be written required Returns: Type Description Effect[HasFiles, OSError, None] Effect that that appends content to file at path","title":"append_bytes()"},{"location":"functions_api/","text":"pfun . functions . identity ( v ) The identity function. Just gives back its argument Examples: >>> identity ( 'value' ) 'value' Parameters: Name Type Description Default v ~A The value to get back required Returns: Type Description ~A v pfun . functions . always ( value ) Get a function that always returns value Examples: >>> f = always ( 1 ) >>> f ( None ) 1 >>> f ( '' ) 1 >>> \"... and so on...\" Parameters: Name Type Description Default value ~A The value to return always required Returns: Type Description Callable[..., ~A] function that always returns value pfun . functions . compose ( f , g , * functions ) Compose functions from left to right Examples: >>> f = lambda v : v * 2 >>> g = compose ( str , f ) >>> g ( 3 ) \"6\" Parameters: Name Type Description Default f Callable[[Any], Any] the outermost function in the composition required g Callable[[Any], Any] the function to be composed with f required functions Callable[[Any], Any] functions to be composed with f and g from left to right () Returns: Type Description Callable[[Any], Any] f composed with g composed with functions from left to right pfun . functions . pipeline ( first , second , * rest ) Compose functions from right to left Examples: >>> f = lambda v : v * 2 >>> g = pipeline ( f , str ) >>> g ( 3 ) \"6\" Parameters: Name Type Description Default first Callable[[Any], Any] the innermost function in the composition required g the function to compose with f required functions functions to compose with first and second from right to left required Returns: Type Description rest composed from right to left, composed with second composed with first pfun . functions . curry ( f ) Get a version of f that can be partially applied Examples: >>> f = lambda a , b : a + b >>> f_curried = curry ( f ) >>> f_curried ( 1 ) functools . partial ( < function < lambda > at 0x1051f0950 > , a = 1 ) >>> f_curried ( 1 )( 1 ) 2 Parameters: Name Type Description Default f Callable The function to curry required Returns: Type Description Callable Curried version of f","title":"pfun.functions"},{"location":"functions_api/#pfun.functions.identity","text":"The identity function. Just gives back its argument Examples: >>> identity ( 'value' ) 'value' Parameters: Name Type Description Default v ~A The value to get back required Returns: Type Description ~A v","title":"identity()"},{"location":"functions_api/#pfun.functions.always","text":"Get a function that always returns value Examples: >>> f = always ( 1 ) >>> f ( None ) 1 >>> f ( '' ) 1 >>> \"... and so on...\" Parameters: Name Type Description Default value ~A The value to return always required Returns: Type Description Callable[..., ~A] function that always returns value","title":"always()"},{"location":"functions_api/#pfun.functions.compose","text":"Compose functions from left to right Examples: >>> f = lambda v : v * 2 >>> g = compose ( str , f ) >>> g ( 3 ) \"6\" Parameters: Name Type Description Default f Callable[[Any], Any] the outermost function in the composition required g Callable[[Any], Any] the function to be composed with f required functions Callable[[Any], Any] functions to be composed with f and g from left to right () Returns: Type Description Callable[[Any], Any] f composed with g composed with functions from left to right","title":"compose()"},{"location":"functions_api/#pfun.functions.pipeline","text":"Compose functions from right to left Examples: >>> f = lambda v : v * 2 >>> g = pipeline ( f , str ) >>> g ( 3 ) \"6\" Parameters: Name Type Description Default first Callable[[Any], Any] the innermost function in the composition required g the function to compose with f required functions functions to compose with first and second from right to left required Returns: Type Description rest composed from right to left, composed with second composed with first","title":"pipeline()"},{"location":"functions_api/#pfun.functions.curry","text":"Get a version of f that can be partially applied Examples: >>> f = lambda a , b : a + b >>> f_curried = curry ( f ) >>> f_curried ( 1 ) functools . partial ( < function < lambda > at 0x1051f0950 > , a = 1 ) >>> f_curried ( 1 )( 1 ) 2 Parameters: Name Type Description Default f Callable The function to curry required Returns: Type Description Callable Curried version of f","title":"curry()"},{"location":"http_api/","text":"Note This module requires optional dependencies. You can install them together with pfun using pip install pfun[http] pfun.http.HTTP dataclass Module for making HTTP requests. __init__ ( self , connector = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , json_serialize =< function dumps at 0x1099fe8c0 > , version = HttpVersion ( major = 1 , minor = 1 ), cookie_jar = None , read_timeout = None , conn_timeout = None , timeout =< object object at 0x10a9a6180 > , raise_for_status = False , connector_owner = True , auto_decompress = True , requote_redirect_url = False , trust_env = False , trace_configs = None ) All keyword arguments are passed to the wrapped aiohttp.ClientSession . Refer to the originial documentation for their meaning. make_request ( self , method , url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a request using HTTP verb method to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> http = HTTP () >>> http . make_request ( 'get' , 'http://foo.com' ) . run ( None ) Response ( ... ) Parameters: Name Type Description Default method str HTTP method to use. One of get , put , post , delete , patch , head or option . required url str target URL for the request required Returns: Type Description Try[ClientError, Response] Effect that produces a Response pfun.http.Response dataclass The result of making a HTTP request. content : bytes dataclass-field The response content cookies : BaseCookie dataclass-field The response cookies encoding : Union [ pfun . maybe . Nothing , pfun . maybe . Just [ str ]] dataclass-field Encoding of the response content if present in the header or if detectable by chardet headers : pfun . dict . Dict [ str , str ] dataclass-field The response headers links : pfun . dict . Dict [ str , str ] dataclass-field The response http link header reason : Union [ pfun . maybe . Nothing , pfun . maybe . Just [ str ]] dataclass-field The reason for the request status, e.g \"OK\" status : int dataclass-field The request status pfun.http.HasHTTP Module provider providing the http module pfun . http . get_session () Get an effect that produces an aiohttp.ClientSession . Use this if you need features of aiohttp that are not supported by the high-level api. Examples: >>> async def use_session ( session : aiohttp . ClientSession ) -> str : ... async with session . get ( 'http://www.google.com' ) as response : ... return await response . text () >>> class Env : ... http = HTTP () >>> get_session () . map ( use_session ) . run ( Env ()) \"<!doctype html> ...\" Returns: Type Description Depends[HasHTTP, aiohttp.ClientSession] Effect that succeeds with aiohttp.ClientSession pfun . http . get ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP get request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> get ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response pfun . http . put ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP put request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> put ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response pfun . http . post ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP post request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> post ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response pfun . http . delete ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP delete request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> delete ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response pfun . http . head ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP head request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> head ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response pfun . http . patch ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP patch request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> patch ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response pfun . http . options ( url , params = None , data = None , json = None , cookies = None , headers = None , skip_auto_headers = None , auth = None , allow_redirects = True , max_redirects = 10 , compress = None , chunked = None , expect100 = False , raise_for_status = None , read_until_eof = True , proxy = None , proxy_auth = None , timeout =< object object at 0x10a9a6180 > , ssl = None , verify_ssl = None , fingerprint = None , ssl_context = None , proxy_headers = None ) Make a HTTP options request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> options ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"pfun.http"},{"location":"http_api/#pfun.http.HTTP","text":"Module for making HTTP requests.","title":"HTTP"},{"location":"http_api/#pfun.http.HTTP.__init__","text":"All keyword arguments are passed to the wrapped aiohttp.ClientSession . Refer to the originial documentation for their meaning.","title":"__init__()"},{"location":"http_api/#pfun.http.HTTP.make_request","text":"Make a request using HTTP verb method to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> http = HTTP () >>> http . make_request ( 'get' , 'http://foo.com' ) . run ( None ) Response ( ... ) Parameters: Name Type Description Default method str HTTP method to use. One of get , put , post , delete , patch , head or option . required url str target URL for the request required Returns: Type Description Try[ClientError, Response] Effect that produces a Response","title":"make_request()"},{"location":"http_api/#pfun.http.Response","text":"The result of making a HTTP request.","title":"Response"},{"location":"http_api/#pfun.http.Response.content","text":"The response content","title":"content"},{"location":"http_api/#pfun.http.Response.cookies","text":"The response cookies","title":"cookies"},{"location":"http_api/#pfun.http.Response.encoding","text":"Encoding of the response content if present in the header or if detectable by chardet","title":"encoding"},{"location":"http_api/#pfun.http.Response.headers","text":"The response headers","title":"headers"},{"location":"http_api/#pfun.http.Response.links","text":"The response http link header","title":"links"},{"location":"http_api/#pfun.http.Response.reason","text":"The reason for the request status, e.g \"OK\"","title":"reason"},{"location":"http_api/#pfun.http.Response.status","text":"The request status","title":"status"},{"location":"http_api/#pfun.http.HasHTTP","text":"Module provider providing the http module","title":"HasHTTP"},{"location":"http_api/#pfun.http.get_session","text":"Get an effect that produces an aiohttp.ClientSession . Use this if you need features of aiohttp that are not supported by the high-level api. Examples: >>> async def use_session ( session : aiohttp . ClientSession ) -> str : ... async with session . get ( 'http://www.google.com' ) as response : ... return await response . text () >>> class Env : ... http = HTTP () >>> get_session () . map ( use_session ) . run ( Env ()) \"<!doctype html> ...\" Returns: Type Description Depends[HasHTTP, aiohttp.ClientSession] Effect that succeeds with aiohttp.ClientSession","title":"get_session()"},{"location":"http_api/#pfun.http.get","text":"Make a HTTP get request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> get ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"get()"},{"location":"http_api/#pfun.http.put","text":"Make a HTTP put request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> put ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"put()"},{"location":"http_api/#pfun.http.post","text":"Make a HTTP post request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> post ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"post()"},{"location":"http_api/#pfun.http.delete","text":"Make a HTTP delete request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> delete ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"delete()"},{"location":"http_api/#pfun.http.head","text":"Make a HTTP head request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> head ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"head()"},{"location":"http_api/#pfun.http.patch","text":"Make a HTTP patch request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> patch ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"patch()"},{"location":"http_api/#pfun.http.options","text":"Make a HTTP options request to URL url . All keyword arguments are passed to aiohttp.ClientSession.request . Refer to the original documentation for their meaning. Examples: >>> class Env : ... http = HTTP () >>> options ( 'http://foo.com' ) . run ( Env ()) Response ( ... ) Parameters: Name Type Description Default url str target URL for the request required Returns: Type Description Effect[HasHTTP, ClientError, Response] Effect that produces a Response","title":"options()"},{"location":"immutable_api/","text":"pfun.immutable.Immutable Super class that makes subclasses immutable using dataclasses Examples: >>> class A ( Immutable ): ... a : str >>> class B ( A ): ... b : str >>> b = B ( 'a' , 'b' ) >>> b . a = 'new value' AttributeError : < __main__ . B object at 0x10f99a0f0 > is immutable clone ( self , ** kwargs ) Make a shallow copy of an instance, potentially overwriting fields given by kwargs Examples: >>> class A ( Immutable ): ... a : str >>> a = A ( 'a' ) >>> a2 = a . clone ( a = 'new value' ) >>> a2 . a \"new value\" Parameters: Name Type Description Default kwargs fields to overwrite {} Returns: Type Description ~T New instance of same type with copied and overwritten fields","title":"pfun.immutable"},{"location":"immutable_api/#pfun.immutable.Immutable","text":"Super class that makes subclasses immutable using dataclasses Examples: >>> class A ( Immutable ): ... a : str >>> class B ( A ): ... b : str >>> b = B ( 'a' , 'b' ) >>> b . a = 'new value' AttributeError : < __main__ . B object at 0x10f99a0f0 > is immutable","title":"Immutable"},{"location":"immutable_api/#pfun.immutable.Immutable.clone","text":"Make a shallow copy of an instance, potentially overwriting fields given by kwargs Examples: >>> class A ( Immutable ): ... a : str >>> a = A ( 'a' ) >>> a2 = a . clone ( a = 'new value' ) >>> a2 . a \"new value\" Parameters: Name Type Description Default kwargs fields to overwrite {} Returns: Type Description ~T New instance of same type with copied and overwritten fields","title":"clone()"},{"location":"immutable_objects_and_data/","text":"Immutable Immutable makes a class (and all classes that inherit from it) immutable. The syntax is much the same as for dataclass or NamedTuple : from pfun.immutable import Immutable class C ( Immutable ): a : int class D ( C ): b : int c = C ( 1 ) c . a = 2 # raises: FrozenInstanceError d = D ( 2 , 2 ) # 'D' inherits the members of C d . b = 2 # raises FrozenInstanceError Immutable uses dataclasses under the hood, so for detailed usage documentation, see the official docs. You can use the entire dataclass api. from dataclasses import field from typing import Tuple class C ( Immutable ): l : Tuple [ int ] = field ( default_factory = tuple ) assert C () . l == () In addition, if the pfun MyPy plugin is enabled, MyPy can check for assignments that will fail at runtime. List List is a functional style list data structure. from pfun.list import List l = List ( range ( 5 )) l2 = l . append ( 5 ) assert l == List ( range ( 5 )) and l2 == List ( range ( 6 )) It supports the same operations as list , with the exception of __setitem__ , which will raise an Exception. In addition, List supplies functional operations such as map and reduce as instance methods assert List ( range ( 3 )) . reduce ( lambda a , b : a + b ) == 3 assert List ( range ( 3 )) . map ( str ) == [ '0' , '1' , '2' ] Dict Dict is a functional style dictionary. from pfun.dict import Dict from pfun.maybe import Just d = Dict ({ 'key' : 'value' }) d2 = d . set ( 'new_key' , 'new_value' ) assert 'new_key' not in d and d2 . get ( 'new_key' ) == Just ( 'new_value' ) It supports the same api as dict which the exception of __setitem__ which will raise an exception, and uses pfun.maybe.Maybe to indicate the presence or absence of a key when using get .","title":"Immutable Objects And Data Structures"},{"location":"immutable_objects_and_data/#immutable","text":"Immutable makes a class (and all classes that inherit from it) immutable. The syntax is much the same as for dataclass or NamedTuple : from pfun.immutable import Immutable class C ( Immutable ): a : int class D ( C ): b : int c = C ( 1 ) c . a = 2 # raises: FrozenInstanceError d = D ( 2 , 2 ) # 'D' inherits the members of C d . b = 2 # raises FrozenInstanceError Immutable uses dataclasses under the hood, so for detailed usage documentation, see the official docs. You can use the entire dataclass api. from dataclasses import field from typing import Tuple class C ( Immutable ): l : Tuple [ int ] = field ( default_factory = tuple ) assert C () . l == () In addition, if the pfun MyPy plugin is enabled, MyPy can check for assignments that will fail at runtime.","title":"Immutable"},{"location":"immutable_objects_and_data/#list","text":"List is a functional style list data structure. from pfun.list import List l = List ( range ( 5 )) l2 = l . append ( 5 ) assert l == List ( range ( 5 )) and l2 == List ( range ( 6 )) It supports the same operations as list , with the exception of __setitem__ , which will raise an Exception. In addition, List supplies functional operations such as map and reduce as instance methods assert List ( range ( 3 )) . reduce ( lambda a , b : a + b ) == 3 assert List ( range ( 3 )) . map ( str ) == [ '0' , '1' , '2' ]","title":"List"},{"location":"immutable_objects_and_data/#dict","text":"Dict is a functional style dictionary. from pfun.dict import Dict from pfun.maybe import Just d = Dict ({ 'key' : 'value' }) d2 = d . set ( 'new_key' , 'new_value' ) assert 'new_key' not in d and d2 . get ( 'new_key' ) == Just ( 'new_value' ) It supports the same api as dict which the exception of __setitem__ which will raise an exception, and uses pfun.maybe.Maybe to indicate the presence or absence of a key when using get .","title":"Dict"},{"location":"install/","text":"From PyPI pfun can be installed from PyPI , for example using pip : $ pip install pfun Some modules such as pfun.sql and pfun.http require optional dependencies. These can be installed with: $ pip install pfun [ sql,http ] MyPy Plugin The types provided by the Python typing module are often not flexible enough to provide precise typing of common functional design patterns. If you use MyPy , pfun provides a plugin that enables more precise types which can identify more bugs caused by type errors. To enable the pfun MyPy plugin, add the following to your MyPy configuration: [mypy] plugins = pfun.mypy_plugin pfun is currently only tested against MyPy 0.800","title":"Install"},{"location":"install/#from-pypi","text":"pfun can be installed from PyPI , for example using pip : $ pip install pfun Some modules such as pfun.sql and pfun.http require optional dependencies. These can be installed with: $ pip install pfun [ sql,http ]","title":"From PyPI"},{"location":"install/#mypy-plugin","text":"The types provided by the Python typing module are often not flexible enough to provide precise typing of common functional design patterns. If you use MyPy , pfun provides a plugin that enables more precise types which can identify more bugs caused by type errors. To enable the pfun MyPy plugin, add the following to your MyPy configuration: [mypy] plugins = pfun.mypy_plugin pfun is currently only tested against MyPy 0.800","title":"MyPy Plugin"},{"location":"list_api/","text":"pfun.list.List __add__ ( self , other ) Concatenate with other Iterable or List Examples: >>> List ( range ( 2 )) + range ( 2 , 4 ) List (( 0 , 1 , 2 , 3 )) Parameters: Name Type Description Default other Iterable[~A] Iterable to concatenate with required Returns: Type Description List[A] new List concatenated with other __radd__ ( self , other ) Concatenate with other Iterable or List Examples: >>> range ( 2 ) + List ( range ( 2 , 4 )) List (( 0 , 1 , 2 , 3 )) Parameters: Name Type Description Default other Iterable[~A] Iterable to concatenate with required Returns: Type Description List[A] new List concatenated with other __repr__ ( self ) Return repr(self). and_then ( self , f ) Chain together functions that produce more than one result Examples: >>> List ( range ( 4 )) . and_then ( lambda v : List ( range ( v ))) [ 0 , 0 , 1 , 0 , 1 , 2 ] Parameters: Name Type Description Default f Callable[[A], List[B]] Function to apply to elements of this List required Returns: Type Description List[B] Concatenated results from applying f to all elements append ( self , a ) Add element to end of list Examples: >>> List ( range ( 3 )) . append ( 3 ) [ 1 , 2 , 3 ] Parameters: Name Type Description Default a ~A Element to append required Returns: Type Description List[A] New List with a appended extend ( self , iterable ) Add all elements from iterable to end of list Examples: >>> List ( range ( 3 )) . extend ( range ( 3 )) [ 0 , 1 , 2 , 0 , 1 , 2 ] Parameters: Name Type Description Default iterable Iterable[~A] Iterable to extend by required Returns: Type Description List[A] New List with extended by iterable filter ( self , f ) Filter elements by the predicate f Examples: >>> List ( range ( 4 )) . filter ( lambda e : e % 2 == 0 ) [ 0 , 2 ] Parameters: Name Type Description Default f Callable[[~A], bool] Function to filter by required Returns: Type Description List[A] new List filtered by f map ( self , f ) Apply f to each element in the list Examples: >>> List ( range ( 2 )) . map ( str ) [ '0' , '1' ] Parameters: Name Type Description Default f Callable[[~A], ~B] Function to apply required Returns: Type Description List[B] new List mapped by f reduce ( self , f , initializer = None ) Aggregate elements by f Examples: >>> List ( range ( 3 )) . reduce ( lambda a , b : a + b ) 3 Parameters: Name Type Description Default f Callable[[~B, ~A], ~B] Function to perform aggregation required initializer Optional[~B] Starting value for aggregation None Returns: Type Description ~B Aggregated result zip ( self , other ) Zip together with another iterable Examples: >>> List ( List ( range ( 2 )) . zip ( range ( 2 ))) [( 0 , 0 ), ( 1 , 1 )] Parameters: Name Type Description Default other Iterable[~B] Iterable to zip with required Returns: Type Description Iterable[Tuple[~A, ~B]] Zip with other pfun . list . for_each ( f , iterable ) Map each in element in iterable to an List by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( lambda v : List ([ v ]), range ( 3 )) List ((( 0 , 1 , 2 ),)) Parameters: Name Type Description Default f Callable[[~A], pfun.list.List[~B]] Function to map over iterable required iterable Iterable[~A] Iterable to map f over required Returns: Type Description pfun.list.List[Iterable[~B]] f mapped over iterable and combined from left to right. pfun . list . sequence ( iterable ) Evaluate each List in iterable from left to right and collect the results Examples: >>> sequence ([ List ([ v ]) for v in range ( 3 )]) List ((( 0 , 1 , 2 ),)) Parameters: Name Type Description Default iterable Iterable[pfun.list.List[~A]] The iterable to collect results from required Returns: Type Description pfun.list.List[Iterable[~A]] List of collected results pfun . list . filter_ ( f , iterable ) Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : List ([ v % 2 == 0 ]), range ( 3 )) List ((( 0 , 2 ),)) Parameters: Name Type Description Default f Callable[[~A], pfun.list.List[bool]] Function to map iterable by required iterable Iterable[~A] Iterable to map by f required Returns: Type Description pfun.list.List[Iterable[~A]] iterable mapped and filtered by f","title":"pfun.list"},{"location":"list_api/#pfun.list.List","text":"","title":"List"},{"location":"list_api/#pfun.list.List.__add__","text":"Concatenate with other Iterable or List Examples: >>> List ( range ( 2 )) + range ( 2 , 4 ) List (( 0 , 1 , 2 , 3 )) Parameters: Name Type Description Default other Iterable[~A] Iterable to concatenate with required Returns: Type Description List[A] new List concatenated with other","title":"__add__()"},{"location":"list_api/#pfun.list.List.__radd__","text":"Concatenate with other Iterable or List Examples: >>> range ( 2 ) + List ( range ( 2 , 4 )) List (( 0 , 1 , 2 , 3 )) Parameters: Name Type Description Default other Iterable[~A] Iterable to concatenate with required Returns: Type Description List[A] new List concatenated with other","title":"__radd__()"},{"location":"list_api/#pfun.list.List.__repr__","text":"Return repr(self).","title":"__repr__()"},{"location":"list_api/#pfun.list.List.and_then","text":"Chain together functions that produce more than one result Examples: >>> List ( range ( 4 )) . and_then ( lambda v : List ( range ( v ))) [ 0 , 0 , 1 , 0 , 1 , 2 ] Parameters: Name Type Description Default f Callable[[A], List[B]] Function to apply to elements of this List required Returns: Type Description List[B] Concatenated results from applying f to all elements","title":"and_then()"},{"location":"list_api/#pfun.list.List.append","text":"Add element to end of list Examples: >>> List ( range ( 3 )) . append ( 3 ) [ 1 , 2 , 3 ] Parameters: Name Type Description Default a ~A Element to append required Returns: Type Description List[A] New List with a appended","title":"append()"},{"location":"list_api/#pfun.list.List.extend","text":"Add all elements from iterable to end of list Examples: >>> List ( range ( 3 )) . extend ( range ( 3 )) [ 0 , 1 , 2 , 0 , 1 , 2 ] Parameters: Name Type Description Default iterable Iterable[~A] Iterable to extend by required Returns: Type Description List[A] New List with extended by iterable","title":"extend()"},{"location":"list_api/#pfun.list.List.filter","text":"Filter elements by the predicate f Examples: >>> List ( range ( 4 )) . filter ( lambda e : e % 2 == 0 ) [ 0 , 2 ] Parameters: Name Type Description Default f Callable[[~A], bool] Function to filter by required Returns: Type Description List[A] new List filtered by f","title":"filter()"},{"location":"list_api/#pfun.list.List.map","text":"Apply f to each element in the list Examples: >>> List ( range ( 2 )) . map ( str ) [ '0' , '1' ] Parameters: Name Type Description Default f Callable[[~A], ~B] Function to apply required Returns: Type Description List[B] new List mapped by f","title":"map()"},{"location":"list_api/#pfun.list.List.reduce","text":"Aggregate elements by f Examples: >>> List ( range ( 3 )) . reduce ( lambda a , b : a + b ) 3 Parameters: Name Type Description Default f Callable[[~B, ~A], ~B] Function to perform aggregation required initializer Optional[~B] Starting value for aggregation None Returns: Type Description ~B Aggregated result","title":"reduce()"},{"location":"list_api/#pfun.list.List.zip","text":"Zip together with another iterable Examples: >>> List ( List ( range ( 2 )) . zip ( range ( 2 ))) [( 0 , 0 ), ( 1 , 1 )] Parameters: Name Type Description Default other Iterable[~B] Iterable to zip with required Returns: Type Description Iterable[Tuple[~A, ~B]] Zip with other","title":"zip()"},{"location":"list_api/#pfun.list.for_each","text":"Map each in element in iterable to an List by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( lambda v : List ([ v ]), range ( 3 )) List ((( 0 , 1 , 2 ),)) Parameters: Name Type Description Default f Callable[[~A], pfun.list.List[~B]] Function to map over iterable required iterable Iterable[~A] Iterable to map f over required Returns: Type Description pfun.list.List[Iterable[~B]] f mapped over iterable and combined from left to right.","title":"for_each()"},{"location":"list_api/#pfun.list.sequence","text":"Evaluate each List in iterable from left to right and collect the results Examples: >>> sequence ([ List ([ v ]) for v in range ( 3 )]) List ((( 0 , 1 , 2 ),)) Parameters: Name Type Description Default iterable Iterable[pfun.list.List[~A]] The iterable to collect results from required Returns: Type Description pfun.list.List[Iterable[~A]] List of collected results","title":"sequence()"},{"location":"list_api/#pfun.list.filter_","text":"Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : List ([ v % 2 == 0 ]), range ( 3 )) List ((( 0 , 2 ),)) Parameters: Name Type Description Default f Callable[[~A], pfun.list.List[bool]] Function to map iterable by required iterable Iterable[~A] Iterable to map by f required Returns: Type Description pfun.list.List[Iterable[~A]] iterable mapped and filtered by f","title":"filter_()"},{"location":"logging_api/","text":"pfun.logging.Logging Module providing logging capability critical ( self , msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.info Examples: >>> Logging () . critical ( 'hello!' ) . run ( None ) CRITICAL : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.critical with msg debug ( self , msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.debug Examples: >>> Logging () . debug ( 'hello!' ) . run ( None ) DEBUG : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.debug with msg error ( self , msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.error Examples: >>> Logging () . error ( 'hello!' ) . run ( None ) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.error with msg exception ( self , msg , stack_info = True , exc_info = True ) Create an effect that calls built-in logging.exception Examples: >>> Logging () . exception ( 'hello!' ) . run ( None ) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message True exc_info Union[bool, ExcInfo] whether to include exception info in the log message True Returns: Type Description Success[None] Effect that calls logging.exception with msg get_logger ( self , name = None ) Create an effect that produces a Logger by calling built-in logging.getLogger Examples: >>> Logging () . get_logger ( 'foo' ) . and_then ( ... lambda logger : logger . info ( 'hello!' ) ... ) . run ( None ) INFO : foo : hello ! Parameters: Name Type Description Default name Optional[str] name of logger None Returns: Type Description Logger Effect that produces a Logger info ( self , msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.info Examples: >>> Logging () . info ( 'hello!' ) . run ( None ) INFO : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.info with msg warning ( self , msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.warning Examples: >>> Logging () . warning ( 'hello!' ) . run ( None ) WARNING : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.warning with msg pfun.logging.HasLogging Module provider for logging capability :type logging: Logging :attribute logging: The logging instance pfun . logging . get_logger ( name = None ) Create an effect that produces a Logger by calling built-in logging.getLogger Examples: >>> class Env : ... logging = Logging () >>> get_logger ( 'foo' ) . and_then ( ... lambda logger : logger . info ( 'hello!' ) ... ) . run ( None ) INFO : foo : hello ! Parameters: Name Type Description Default name Optional[str] name of logger None Returns: Type Description Depends[HasLogging, Logger] Effect that produces a Logger pfun . logging . debug ( msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.debug Examples: >>> class Env : ... logging = Logging () >>> debug ( 'hello!' ) . run ( Env ()) DEBUG : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.debug with msg pfun . logging . info ( msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.info Examples: >>> class Env : ... logging = Logging () >>> info ( 'hello!' ) . run ( Env ()) INFO : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.info with msg pfun . logging . warning ( msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.warning Examples: >>> class Env : ... logging = Logging () >>> warning ( 'hello!' ) . run ( Env ()) WARNING : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.warning with msg pfun . logging . error ( msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.error Examples: >>> class Env : ... logging = Logging () >>> error ( 'hello!' ) . run ( Env ()) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.error with msg pfun . logging . exception ( msg , stack_info = True , exc_info = True ) Create an effect that calls built-in logging.exception Examples: >>> class Env : ... logging = Logging () >>> exception ( 'hello!' ) . run ( Env ()) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message True exc_info Union[bool, ExcInfo] whether to include exception info in the log message True Returns: Type Description Depends[HasLogging, None] Effect that calls logging.exception with msg pfun . logging . critical ( msg , stack_info = False , exc_info = False ) Create an effect that calls built-in logging.critical Examples: >>> class Env : ... logging = Logging () >>> critical ( 'hello!' ) . run ( Env ()) CRITICAL : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.critical with msg","title":"pfun.logging"},{"location":"logging_api/#pfun.logging.Logging","text":"Module providing logging capability","title":"Logging"},{"location":"logging_api/#pfun.logging.Logging.critical","text":"Create an effect that calls built-in logging.info Examples: >>> Logging () . critical ( 'hello!' ) . run ( None ) CRITICAL : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.critical with msg","title":"critical()"},{"location":"logging_api/#pfun.logging.Logging.debug","text":"Create an effect that calls built-in logging.debug Examples: >>> Logging () . debug ( 'hello!' ) . run ( None ) DEBUG : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.debug with msg","title":"debug()"},{"location":"logging_api/#pfun.logging.Logging.error","text":"Create an effect that calls built-in logging.error Examples: >>> Logging () . error ( 'hello!' ) . run ( None ) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.error with msg","title":"error()"},{"location":"logging_api/#pfun.logging.Logging.exception","text":"Create an effect that calls built-in logging.exception Examples: >>> Logging () . exception ( 'hello!' ) . run ( None ) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message True exc_info Union[bool, ExcInfo] whether to include exception info in the log message True Returns: Type Description Success[None] Effect that calls logging.exception with msg","title":"exception()"},{"location":"logging_api/#pfun.logging.Logging.get_logger","text":"Create an effect that produces a Logger by calling built-in logging.getLogger Examples: >>> Logging () . get_logger ( 'foo' ) . and_then ( ... lambda logger : logger . info ( 'hello!' ) ... ) . run ( None ) INFO : foo : hello ! Parameters: Name Type Description Default name Optional[str] name of logger None Returns: Type Description Logger Effect that produces a Logger","title":"get_logger()"},{"location":"logging_api/#pfun.logging.Logging.info","text":"Create an effect that calls built-in logging.info Examples: >>> Logging () . info ( 'hello!' ) . run ( None ) INFO : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.info with msg","title":"info()"},{"location":"logging_api/#pfun.logging.Logging.warning","text":"Create an effect that calls built-in logging.warning Examples: >>> Logging () . warning ( 'hello!' ) . run ( None ) WARNING : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Success[None] Effect that calls logging.warning with msg","title":"warning()"},{"location":"logging_api/#pfun.logging.HasLogging","text":"Module provider for logging capability :type logging: Logging :attribute logging: The logging instance","title":"HasLogging"},{"location":"logging_api/#pfun.logging.get_logger","text":"Create an effect that produces a Logger by calling built-in logging.getLogger Examples: >>> class Env : ... logging = Logging () >>> get_logger ( 'foo' ) . and_then ( ... lambda logger : logger . info ( 'hello!' ) ... ) . run ( None ) INFO : foo : hello ! Parameters: Name Type Description Default name Optional[str] name of logger None Returns: Type Description Depends[HasLogging, Logger] Effect that produces a Logger","title":"get_logger()"},{"location":"logging_api/#pfun.logging.debug","text":"Create an effect that calls built-in logging.debug Examples: >>> class Env : ... logging = Logging () >>> debug ( 'hello!' ) . run ( Env ()) DEBUG : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.debug with msg","title":"debug()"},{"location":"logging_api/#pfun.logging.info","text":"Create an effect that calls built-in logging.info Examples: >>> class Env : ... logging = Logging () >>> info ( 'hello!' ) . run ( Env ()) INFO : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.info with msg","title":"info()"},{"location":"logging_api/#pfun.logging.warning","text":"Create an effect that calls built-in logging.warning Examples: >>> class Env : ... logging = Logging () >>> warning ( 'hello!' ) . run ( Env ()) WARNING : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.warning with msg","title":"warning()"},{"location":"logging_api/#pfun.logging.error","text":"Create an effect that calls built-in logging.error Examples: >>> class Env : ... logging = Logging () >>> error ( 'hello!' ) . run ( Env ()) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.error with msg","title":"error()"},{"location":"logging_api/#pfun.logging.exception","text":"Create an effect that calls built-in logging.exception Examples: >>> class Env : ... logging = Logging () >>> exception ( 'hello!' ) . run ( Env ()) ERROR : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message True exc_info Union[bool, ExcInfo] whether to include exception info in the log message True Returns: Type Description Depends[HasLogging, None] Effect that calls logging.exception with msg","title":"exception()"},{"location":"logging_api/#pfun.logging.critical","text":"Create an effect that calls built-in logging.critical Examples: >>> class Env : ... logging = Logging () >>> critical ( 'hello!' ) . run ( Env ()) CRITICAL : root : hello ! Parameters: Name Type Description Default msg str the log message required stack_info bool whether to include stack information in the log message False exc_info Union[bool, ExcInfo] whether to include exception info in the log message False Returns: Type Description Depends[HasLogging, None] Effect that calls logging.critical with msg","title":"critical()"},{"location":"maybe_api/","text":"pfun . maybe . Maybe Type-alias for Union[Nothing, Just[TypeVar('A')]] pfun.maybe.Just dataclass Represents the result of a successful computation get : + A dataclass-field The result of the computation __eq__ ( self , other ) Test if other is a Just Args; other: Value to compare with Returns: Type Description bool True if other is a Just and its wrapped value equals the wrapped value of this instance and_then ( self , f ) Chain together functional calls, carrying along the state of the computation that may fail. Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) Just ( 0.5 ) >>> Just ( 0 ) . and_then ( f ) Nothing () Parameters: Name Type Description Default f Callable[[+A], Maybe[B]] the function to call required Returns: Type Description Maybe[B] Just wrapping a value of type A if the computation was successful, Nothing otherwise. map ( self , f ) Map the result of a possibly failed computation Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) . map ( str ) Just ( '0.5' ) >>> Just ( 0 ) . and_then ( f ) . map ( str ) Nothing () Parameters: Name Type Description Default f Callable[[+A], ~B] Function to apply to the result required Returns: Type Description Maybe[B] Just wrapping result of type B if the computation was or_else ( self , default ) Try to get the result of the possibly failed computation if it was successful. Examples: >>> Just ( 1 ) . or_else ( 2 ) 1 >>> Nothing () . or_else ( 2 ) 2 Parameters: Name Type Description Default default ~B Value to return if computation has failed required Returns: Type Description Union[+A, ~B] value if this is Just(value) , default_value if this Nothing pfun.maybe.Nothing dataclass Represents a failed computation __eq__ ( self , other ) Test if other is a Nothing Parameters: Name Type Description Default other Any Value to compare with required Returns: Type Description bool True if other is a Nothing , False otherwise and_then ( self , f ) Chain together functional calls, carrying along the state of the computation that may fail. Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) Just ( 0.5 ) >>> Just ( 0 ) . and_then ( f ) Nothing () Parameters: Name Type Description Default f Callable[[+A], Maybe[B]] the function to call required Returns: Type Description Maybe[B] Just wrapping a value of type A if the computation was successful, Nothing otherwise. map ( self , f ) Map the result of a possibly failed computation Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) . map ( str ) Just ( '0.5' ) >>> Just ( 0 ) . and_then ( f ) . map ( str ) Nothing () Parameters: Name Type Description Default f Callable[[Any], ~B] Function to apply to the result required Returns: Type Description Maybe[B] Just wrapping result of type B if the computation was or_else ( self , default ) Try to get the result of the possibly failed computation if it was successful. Examples: >>> Just ( 1 ) . or_else ( 2 ) 1 >>> Nothing () . or_else ( 2 ) 2 Parameters: Name Type Description Default default ~B Value to return if computation has failed required Returns: Type Description Union[+A, ~B] value if this is Just(value) , default_value if this Nothing pfun . maybe . maybe ( f ) Wrap a function that may raise an exception with a Maybe . Can also be used as a decorator. Useful for turning any function into a monadic function Examples: >>> to_int = maybe ( int ) >>> to_int ( \"1\" ) Just ( 1 ) >>> to_int ( \"Whoops\" ) Nothing () Parameters: Name Type Description Default f Callable[..., ~B] Function to wrap required Returns: Type Description Callable[..., Union[pfun.maybe.Nothing, pfun.maybe.Just[~B]]] f wrapped with a Maybe pfun . maybe . flatten ( maybes ) Extract value from each Maybe , ignoring elements that are Nothing Examples: >>> flatten ([ Just ( 1 ), Nothing (), Just ( 2 )]) List (( 1 , 2 )) Parameters: Name Type Description Default maybes Sequence[Union[pfun.maybe.Nothing, pfun.maybe.Just[+A]]] Seqence of Maybe required Returns: Type Description pfun.list.List[+A] List of unwrapped values pfun . maybe . for_each ( f , iterable ) Map each in element in iterable to an Maybe by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( Just , range ( 3 )) Just (( 0 , 1 , 2 )) Parameters: Name Type Description Default f Callable[[+A], Union[pfun.maybe.Nothing, pfun.maybe.Just[~B]]] Function to map over iterable required iterable Iterable[+A] Iterable to map f over required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[Iterable[~B]]] f mapped over iterable and combined from left to right. pfun . maybe . sequence ( iterable ) Evaluate each Maybe in iterable from left to right and collect the results Examples: >>> sequence ([ Just ( v ) for v in range ( 3 )]) Just (( 0 , 1 , 2 )) Parameters: Name Type Description Default iterable Iterable[Union[pfun.maybe.Nothing, pfun.maybe.Just[+A]]] The iterable to collect results from required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[Iterable[+A]]] Maybe of collected results pfun . maybe . filter_ ( f , iterable ) Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : Just ( v % 2 == 0 ), range ( 3 )) Just (( 0 , 2 )) Parameters: Name Type Description Default f Callable[[+A], Union[pfun.maybe.Nothing, pfun.maybe.Just[bool]]] Function to map iterable by required iterable Iterable[+A] Iterable to map by f required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[Iterable[+A]]] iterable mapped and filtered by f pfun . maybe . from_optional ( optional ) Return a possible None value to Maybe Examples: >>> from_optional ( 'value' ) Just ( 'value' ) >>> from_optional ( None ) Nothing () Parameters: Name Type Description Default optional Optional[+A] optional value to convert to Maybe required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[+A]] Just(optional) if optional is not None , Nothing otherwise","title":"pfun.maybe"},{"location":"maybe_api/#pfun.maybe.Maybe","text":"Type-alias for Union[Nothing, Just[TypeVar('A')]]","title":"Maybe"},{"location":"maybe_api/#pfun.maybe.Just","text":"Represents the result of a successful computation","title":"Just"},{"location":"maybe_api/#pfun.maybe.Just.get","text":"The result of the computation","title":"get"},{"location":"maybe_api/#pfun.maybe.Just.__eq__","text":"Test if other is a Just Args; other: Value to compare with Returns: Type Description bool True if other is a Just and its wrapped value equals the wrapped value of this instance","title":"__eq__()"},{"location":"maybe_api/#pfun.maybe.Just.and_then","text":"Chain together functional calls, carrying along the state of the computation that may fail. Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) Just ( 0.5 ) >>> Just ( 0 ) . and_then ( f ) Nothing () Parameters: Name Type Description Default f Callable[[+A], Maybe[B]] the function to call required Returns: Type Description Maybe[B] Just wrapping a value of type A if the computation was successful, Nothing otherwise.","title":"and_then()"},{"location":"maybe_api/#pfun.maybe.Just.map","text":"Map the result of a possibly failed computation Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) . map ( str ) Just ( '0.5' ) >>> Just ( 0 ) . and_then ( f ) . map ( str ) Nothing () Parameters: Name Type Description Default f Callable[[+A], ~B] Function to apply to the result required Returns: Type Description Maybe[B] Just wrapping result of type B if the computation was","title":"map()"},{"location":"maybe_api/#pfun.maybe.Just.or_else","text":"Try to get the result of the possibly failed computation if it was successful. Examples: >>> Just ( 1 ) . or_else ( 2 ) 1 >>> Nothing () . or_else ( 2 ) 2 Parameters: Name Type Description Default default ~B Value to return if computation has failed required Returns: Type Description Union[+A, ~B] value if this is Just(value) , default_value if this Nothing","title":"or_else()"},{"location":"maybe_api/#pfun.maybe.Nothing","text":"Represents a failed computation","title":"Nothing"},{"location":"maybe_api/#pfun.maybe.Nothing.__eq__","text":"Test if other is a Nothing Parameters: Name Type Description Default other Any Value to compare with required Returns: Type Description bool True if other is a Nothing , False otherwise","title":"__eq__()"},{"location":"maybe_api/#pfun.maybe.Nothing.and_then","text":"Chain together functional calls, carrying along the state of the computation that may fail. Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) Just ( 0.5 ) >>> Just ( 0 ) . and_then ( f ) Nothing () Parameters: Name Type Description Default f Callable[[+A], Maybe[B]] the function to call required Returns: Type Description Maybe[B] Just wrapping a value of type A if the computation was successful, Nothing otherwise.","title":"and_then()"},{"location":"maybe_api/#pfun.maybe.Nothing.map","text":"Map the result of a possibly failed computation Examples: >>> f = lambda i : Just ( 1 / i ) if i != 0 else Nothing () >>> Just ( 2 ) . and_then ( f ) . map ( str ) Just ( '0.5' ) >>> Just ( 0 ) . and_then ( f ) . map ( str ) Nothing () Parameters: Name Type Description Default f Callable[[Any], ~B] Function to apply to the result required Returns: Type Description Maybe[B] Just wrapping result of type B if the computation was","title":"map()"},{"location":"maybe_api/#pfun.maybe.Nothing.or_else","text":"Try to get the result of the possibly failed computation if it was successful. Examples: >>> Just ( 1 ) . or_else ( 2 ) 1 >>> Nothing () . or_else ( 2 ) 2 Parameters: Name Type Description Default default ~B Value to return if computation has failed required Returns: Type Description Union[+A, ~B] value if this is Just(value) , default_value if this Nothing","title":"or_else()"},{"location":"maybe_api/#pfun.maybe.maybe","text":"Wrap a function that may raise an exception with a Maybe . Can also be used as a decorator. Useful for turning any function into a monadic function Examples: >>> to_int = maybe ( int ) >>> to_int ( \"1\" ) Just ( 1 ) >>> to_int ( \"Whoops\" ) Nothing () Parameters: Name Type Description Default f Callable[..., ~B] Function to wrap required Returns: Type Description Callable[..., Union[pfun.maybe.Nothing, pfun.maybe.Just[~B]]] f wrapped with a Maybe","title":"maybe()"},{"location":"maybe_api/#pfun.maybe.flatten","text":"Extract value from each Maybe , ignoring elements that are Nothing Examples: >>> flatten ([ Just ( 1 ), Nothing (), Just ( 2 )]) List (( 1 , 2 )) Parameters: Name Type Description Default maybes Sequence[Union[pfun.maybe.Nothing, pfun.maybe.Just[+A]]] Seqence of Maybe required Returns: Type Description pfun.list.List[+A] List of unwrapped values","title":"flatten()"},{"location":"maybe_api/#pfun.maybe.for_each","text":"Map each in element in iterable to an Maybe by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> for_each ( Just , range ( 3 )) Just (( 0 , 1 , 2 )) Parameters: Name Type Description Default f Callable[[+A], Union[pfun.maybe.Nothing, pfun.maybe.Just[~B]]] Function to map over iterable required iterable Iterable[+A] Iterable to map f over required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[Iterable[~B]]] f mapped over iterable and combined from left to right.","title":"for_each()"},{"location":"maybe_api/#pfun.maybe.sequence","text":"Evaluate each Maybe in iterable from left to right and collect the results Examples: >>> sequence ([ Just ( v ) for v in range ( 3 )]) Just (( 0 , 1 , 2 )) Parameters: Name Type Description Default iterable Iterable[Union[pfun.maybe.Nothing, pfun.maybe.Just[+A]]] The iterable to collect results from required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[Iterable[+A]]] Maybe of collected results","title":"sequence()"},{"location":"maybe_api/#pfun.maybe.filter_","text":"Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter ( lambda v : Just ( v % 2 == 0 ), range ( 3 )) Just (( 0 , 2 )) Parameters: Name Type Description Default f Callable[[+A], Union[pfun.maybe.Nothing, pfun.maybe.Just[bool]]] Function to map iterable by required iterable Iterable[+A] Iterable to map by f required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[Iterable[+A]]] iterable mapped and filtered by f","title":"filter_()"},{"location":"maybe_api/#pfun.maybe.from_optional","text":"Return a possible None value to Maybe Examples: >>> from_optional ( 'value' ) Just ( 'value' ) >>> from_optional ( None ) Nothing () Parameters: Name Type Description Default optional Optional[+A] optional value to convert to Maybe required Returns: Type Description Union[pfun.maybe.Nothing, pfun.maybe.Just[+A]] Just(optional) if optional is not None , Nothing otherwise","title":"from_optional()"},{"location":"other_resources/","text":"Articles Purely Functional Python With Static Types Be More Lazy, Become More Productive Completely Type-Safe Error Handling in Python Completely Type-Safe Dependency Injection in Python Examples Todo-Backend (implementation of todobackend.com ) Similar Projects returns toolz awesome-functional-python Zio (a Scala library that inspired pfun.effect )","title":"Other Resources"},{"location":"other_resources/#articles","text":"Purely Functional Python With Static Types Be More Lazy, Become More Productive Completely Type-Safe Error Handling in Python Completely Type-Safe Dependency Injection in Python","title":"Articles"},{"location":"other_resources/#examples","text":"Todo-Backend (implementation of todobackend.com )","title":"Examples"},{"location":"other_resources/#similar-projects","text":"returns toolz awesome-functional-python Zio (a Scala library that inspired pfun.effect )","title":"Similar Projects"},{"location":"ref_api/","text":"pfun.ref.Ref dataclass Wraps a value that can be mutated as an Effect __init__ ( self , value ) Parameters: Name Type Description Default value A The initial state required get ( self ) Get an Effect that reads the current state of the value Examples: >>> ref = Ref ( 'the state' ) >>> ref . get () . run ( None ) 'the state' Returns: Type Description Success[A] Effect that reads the current state modify ( self , f ) Modify the value wrapped by this Ref by applying f in isolation Examples: >>> ref = Ref ([]) >>> ref . modify ( lambda l : l + [ 1 ]) . run ( None ) None >>> ref . value [ 1 ] Parameters: Name Type Description Default f Callable[[A], A] function that accepts the current state and returns a new state required Returns: Type Description Success[None] Effect that updates the state to the result of f put ( self , value ) Get an Effect that updates the current state of the value Examples: >>> ref = Ref ( 'initial state' ) >>> ref . put ( 'new state' ) . run ( None ) None >>> ref . value 'new state' Parameters: Name Type Description Default value A new state required Returns: Type Description Success[None] Effect that updates the state try_modify ( self , f ) Try to update the current state with the result of f if it succeeds. The state is updated if f returns a Right value, and kept as is otherwise Examples: >>> from pfun.either import Left , Right >>> ref = Ref ( 'initial state' ) >>> ref . try_modify ( lambda _ : Left ( 'Whoops!' )) . either () . run ( None ) Left ( 'Whoops!' ) >>> ref . value 'initial state' >>> ref . try_modify ( lambda _ : Right ( 'new state' )) . run ( None ) None >>> ref . value 'new state' Parameters: Name Type Description Default f Callable[[A], Either[E, A]] function that accepts the current state and returns a Right wrapping a new state or a Left value wrapping an error required Returns: Type Description Try[E, None] an Effect that updates the state if f succeeds","title":"pfun.ref"},{"location":"ref_api/#pfun.ref.Ref","text":"Wraps a value that can be mutated as an Effect","title":"Ref"},{"location":"ref_api/#pfun.ref.Ref.__init__","text":"Parameters: Name Type Description Default value A The initial state required","title":"__init__()"},{"location":"ref_api/#pfun.ref.Ref.get","text":"Get an Effect that reads the current state of the value Examples: >>> ref = Ref ( 'the state' ) >>> ref . get () . run ( None ) 'the state' Returns: Type Description Success[A] Effect that reads the current state","title":"get()"},{"location":"ref_api/#pfun.ref.Ref.modify","text":"Modify the value wrapped by this Ref by applying f in isolation Examples: >>> ref = Ref ([]) >>> ref . modify ( lambda l : l + [ 1 ]) . run ( None ) None >>> ref . value [ 1 ] Parameters: Name Type Description Default f Callable[[A], A] function that accepts the current state and returns a new state required Returns: Type Description Success[None] Effect that updates the state to the result of f","title":"modify()"},{"location":"ref_api/#pfun.ref.Ref.put","text":"Get an Effect that updates the current state of the value Examples: >>> ref = Ref ( 'initial state' ) >>> ref . put ( 'new state' ) . run ( None ) None >>> ref . value 'new state' Parameters: Name Type Description Default value A new state required Returns: Type Description Success[None] Effect that updates the state","title":"put()"},{"location":"ref_api/#pfun.ref.Ref.try_modify","text":"Try to update the current state with the result of f if it succeeds. The state is updated if f returns a Right value, and kept as is otherwise Examples: >>> from pfun.either import Left , Right >>> ref = Ref ( 'initial state' ) >>> ref . try_modify ( lambda _ : Left ( 'Whoops!' )) . either () . run ( None ) Left ( 'Whoops!' ) >>> ref . value 'initial state' >>> ref . try_modify ( lambda _ : Right ( 'new state' )) . run ( None ) None >>> ref . value 'new state' Parameters: Name Type Description Default f Callable[[A], Either[E, A]] function that accepts the current state and returns a Right wrapping a new state or a Left value wrapping an error required Returns: Type Description Try[E, None] an Effect that updates the state if f succeeds","title":"try_modify()"},{"location":"sql_api/","text":"Note This module requires optional dependencies. You can install them together with pfun using pip install pfun[sql] pfun . sql . Results Type-alias for pfun.list.List[pfun.dict.Dict[str, typing.Any]] pfun.sql.SQL dataclass Module providing postgres sql client capability __init__ ( self , connection_str ) Create an SQL module Parameters: Name Type Description Default connection_str str connection string of the format postgres://<user>:<password>@<host>/<database> required Exceptions: Type Description MalformedConnectionStr if the connection string does not conform to the postgres scheme execute ( self , query , * args , * , timeout = None ) Get an Effect that executes query Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . execute ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... 'bob' , ... 32 ... ) . run ( None ) 'INSERT 1' Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Try[asyncpg.PostgresError, str] Effect that executes query and produces the database response execute_many ( self , query , args , timeout = None ) Get an Effect that executes query for each argument in args Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . execute_many ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... [( 'bob' , 32 ), ( 'alice' , 20 )] ... ) . run ( None ) 'INSERT 2' Parameters: Name Type Description Default query str query to execute required args Iterable[Any] arguments for query required timeout float query timeout None Returns: Type Description Try[asyncpg.PostgresError, Iterable[str]] Effect that executes query with all args in args and produces a database response for each query fetch ( self , query , * args , * , timeout = None ) Get an Effect that executes query and returns the results as a List of Dict Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . fetch ( 'select * from users' ) . run ( None ) List (( Dict ({ 'name' : 'bob' , 'age' : 32 }),)) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Try[asyncpg.PostgresError, Results] Effect that retrieves rows returned by query as Results fetch_one ( self , query , * args , * , timeout = None ) Get an Effect that executes query and returns the first result as a Dict or fails with EmptyResultSetError` if the result set is empty Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . fetch_one ( 'select * from users' ) . run ( None ) Dict ({ 'name' : 'bob' , 'age' : 32 }) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Try[SQLError, Dict[str, Any]] Effect that retrieves the first row returned by query as pfun.dict.Dict[str, Any] get_connection ( self ) Get an Effect that produces a asyncpg.Connection . Used to work with asyncpg directly. Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . get_connection () . run ( None ) < asyncpg . connection . Connection at ...> Returns: Type Description Try[asyncpg.PostgresError, asyncpg.Connection] Effect that produces asyncpg.Connection pfun.sql.MalformedConnectionStr Error returned when a malformed connection str is passed to SQL pfun.sql.HasSQL Module provider for the SQL module pfun . sql . as_type ( type_ , results ) Convert database results to type_ Examples: >>> results = pfun . effect . success ( ... pfun . List ([ pfun . Dict ( dict ( name = 'bob' , age = 32 ))]) ... ) >>> class User ( pfun . Immutable ): ... name : str ... age : int >>> results . and_then ( as_type ( User ))( None ) List (( User ( name = 'bob' , age = 32 ),)) Parameters: Name Type Description Default type_ Type[T] type to convert database results to required results Results database results to convert required :return: List of database results converted to type_ pfun . sql . execute ( query , * args , * , timeout = None ) Get an Effect that executes query Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> execute ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... 'bob' , ... 32 ... ) . run ( Env ()) 'INSERT 1' Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Effect[HasSQL, asyncpg.PostgresError, str] Effect that executes query and produces the database response pfun . sql . execute_many ( query , args , timeout = None ) Get an Effect that executes query for each argument in args Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> execute_many ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... [( 'bob' , 32 ), ( 'alice' , 20 )] ... ) . run ( Env ()) 'INSERT 2' Parameters: Name Type Description Default query str query to execute required args Iterable[Any] arguments for query required timeout float query timeout None Returns: Type Description Effect[HasSQL, asyncpg.PostgresError, Iterable[str]] Effect that executes query with all args in args and produces a database response for each query pfun . sql . fetch ( query , * args , * , timeout = None ) Get an Effect that executes query and returns the results as a List of Dict Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> fetch ( 'select * from users' )( Env ()) List (( Dict ({ 'name' : 'bob' , 'age' : 32 }),)) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Effect[HasSQL, asyncpg.PostgresError, Results] Effect that retrieves rows returned by query as Results pfun . sql . fetch_one ( query , * args , * , timeout = None ) Get an Effect that executes query and returns the first result as a Dict or fails with EmptyResultSetError if the result set is empty Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> fetch_one ( 'select * from users' )( None ) Dict ({ 'name' : 'bob' , 'age' : 32 }) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Effect[HasSQL, SQLError, Dict[str, Any]] Effect that retrieves the first row returned by query as pfun.dict.Dict[str, Any]","title":"pfun.sql"},{"location":"sql_api/#pfun.sql.Results","text":"Type-alias for pfun.list.List[pfun.dict.Dict[str, typing.Any]]","title":"Results"},{"location":"sql_api/#pfun.sql.SQL","text":"Module providing postgres sql client capability","title":"SQL"},{"location":"sql_api/#pfun.sql.SQL.__init__","text":"Create an SQL module Parameters: Name Type Description Default connection_str str connection string of the format postgres://<user>:<password>@<host>/<database> required Exceptions: Type Description MalformedConnectionStr if the connection string does not conform to the postgres scheme","title":"__init__()"},{"location":"sql_api/#pfun.sql.SQL.execute","text":"Get an Effect that executes query Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . execute ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... 'bob' , ... 32 ... ) . run ( None ) 'INSERT 1' Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Try[asyncpg.PostgresError, str] Effect that executes query and produces the database response","title":"execute()"},{"location":"sql_api/#pfun.sql.SQL.execute_many","text":"Get an Effect that executes query for each argument in args Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . execute_many ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... [( 'bob' , 32 ), ( 'alice' , 20 )] ... ) . run ( None ) 'INSERT 2' Parameters: Name Type Description Default query str query to execute required args Iterable[Any] arguments for query required timeout float query timeout None Returns: Type Description Try[asyncpg.PostgresError, Iterable[str]] Effect that executes query with all args in args and produces a database response for each query","title":"execute_many()"},{"location":"sql_api/#pfun.sql.SQL.fetch","text":"Get an Effect that executes query and returns the results as a List of Dict Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . fetch ( 'select * from users' ) . run ( None ) List (( Dict ({ 'name' : 'bob' , 'age' : 32 }),)) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Try[asyncpg.PostgresError, Results] Effect that retrieves rows returned by query as Results","title":"fetch()"},{"location":"sql_api/#pfun.sql.SQL.fetch_one","text":"Get an Effect that executes query and returns the first result as a Dict or fails with EmptyResultSetError` if the result set is empty Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . fetch_one ( 'select * from users' ) . run ( None ) Dict ({ 'name' : 'bob' , 'age' : 32 }) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Try[SQLError, Dict[str, Any]] Effect that retrieves the first row returned by query as pfun.dict.Dict[str, Any]","title":"fetch_one()"},{"location":"sql_api/#pfun.sql.SQL.get_connection","text":"Get an Effect that produces a asyncpg.Connection . Used to work with asyncpg directly. Examples: >>> sql = SQL ( 'postgres://user@host/database' ) >>> sql . get_connection () . run ( None ) < asyncpg . connection . Connection at ...> Returns: Type Description Try[asyncpg.PostgresError, asyncpg.Connection] Effect that produces asyncpg.Connection","title":"get_connection()"},{"location":"sql_api/#pfun.sql.MalformedConnectionStr","text":"Error returned when a malformed connection str is passed to SQL","title":"MalformedConnectionStr"},{"location":"sql_api/#pfun.sql.HasSQL","text":"Module provider for the SQL module","title":"HasSQL"},{"location":"sql_api/#pfun.sql.as_type","text":"Convert database results to type_ Examples: >>> results = pfun . effect . success ( ... pfun . List ([ pfun . Dict ( dict ( name = 'bob' , age = 32 ))]) ... ) >>> class User ( pfun . Immutable ): ... name : str ... age : int >>> results . and_then ( as_type ( User ))( None ) List (( User ( name = 'bob' , age = 32 ),)) Parameters: Name Type Description Default type_ Type[T] type to convert database results to required results Results database results to convert required :return: List of database results converted to type_","title":"as_type()"},{"location":"sql_api/#pfun.sql.execute","text":"Get an Effect that executes query Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> execute ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... 'bob' , ... 32 ... ) . run ( Env ()) 'INSERT 1' Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Effect[HasSQL, asyncpg.PostgresError, str] Effect that executes query and produces the database response","title":"execute()"},{"location":"sql_api/#pfun.sql.execute_many","text":"Get an Effect that executes query for each argument in args Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> execute_many ( ... 'INSERT INTO users(name, age) VALUES($1, $2)' , ... [( 'bob' , 32 ), ( 'alice' , 20 )] ... ) . run ( Env ()) 'INSERT 2' Parameters: Name Type Description Default query str query to execute required args Iterable[Any] arguments for query required timeout float query timeout None Returns: Type Description Effect[HasSQL, asyncpg.PostgresError, Iterable[str]] Effect that executes query with all args in args and produces a database response for each query","title":"execute_many()"},{"location":"sql_api/#pfun.sql.fetch","text":"Get an Effect that executes query and returns the results as a List of Dict Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> fetch ( 'select * from users' )( Env ()) List (( Dict ({ 'name' : 'bob' , 'age' : 32 }),)) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Effect[HasSQL, asyncpg.PostgresError, Results] Effect that retrieves rows returned by query as Results","title":"fetch()"},{"location":"sql_api/#pfun.sql.fetch_one","text":"Get an Effect that executes query and returns the first result as a Dict or fails with EmptyResultSetError if the result set is empty Examples: >>> class Env : ... sql = SQL ( 'postgres://user@host/database' ) >>> fetch_one ( 'select * from users' )( None ) Dict ({ 'name' : 'bob' , 'age' : 32 }) Parameters: Name Type Description Default query str query to execute required args Any arguments for query () timeout float query timeout None Returns: Type Description Effect[HasSQL, SQLError, Dict[str, Any]] Effect that retrieves the first row returned by query as pfun.dict.Dict[str, Any]","title":"fetch_one()"},{"location":"stack_safety/","text":"Its common to use recursion rather than looping in pure functional programming to avoid mutating a local variable. Consider e.g the following implementation of the factorial function: def factorial ( n : int ) -> int : if n == 1 : return 1 return n * factorial ( n - 1 ) Called with a large enough value for n , the recursive calls will overflow the python stack. A common solution to this problem in other languages that perform tail-call-optimization is to rewrite the function to put the recursive call in tail-call position. def factorial ( n : int ) -> int : def factorial_acc ( n : int , acc : int ) -> int : if n == 1 : return acc return factorial_acc ( n - 1 , n * acc ) return factorial_acc ( n , 1 ) In Python however, this is not enough to solve the problem because Python does not perform tail-call-optimization. Because Python doesn't optimize tail calls, we need to use a data structure called a trampoline to wrap the recursive calls into objects that can be interpreted in constant stack space, by letting the function return immediately at each recursive step. from pfun.trampoline import Trampoline , Done , Call def factorial ( n : int ) -> int : def factorial_acc ( n : int , acc : int ) -> Trampoline [ int ]: if n == 1 : return Done ( acc ) return Call ( lambda : factorial_acc ( n - 1 , n * acc )) return factorial_acc ( n , 1 ) . run () However note that in most cases a recursive function can be rewritten into an iterative one that looks completely pure to the caller because it only mutates local variables: def factorial ( n : int ) -> int : acc = 1 for i in range ( 1 , n + 1 ): acc *= i return acc This is the recommended way of solving recursive problems (when it doesn't break referential transparency ), because it avoids overflowing the stack, and is often easier to understand.","title":"Stack-Safety And Recursion"},{"location":"subprocess_api/","text":"pfun.subprocess.Subprocess dataclass Module that enables running commands in the shell run_in_shell ( self , cmd , stdin =- 1 , stdout =- 1 , stderr =- 1 ) Get an Effect that runs cmd in the shell Examples: >>> Subprocess () . run_in_shell ( 'cat foo.txt' ) . run ( None ) ( b 'contents of foo.txt' , b '' ) Parameters: Name Type Description Default cmd str the command to run required stdin Union[IO, int] input pipe for the subprocess -1 stdout Union[IO, int] output pipe for the subprocess -1 stderr Union[IO, int] error pipe for the subprocess -1 Returns: Type Description Try[CalledProcessError, Tuple[bytes, bytes]] Effect that runs cmd in the shell and produces a tuple of (stdout, stderr) pfun.subprocess.HasSubprocess Module provider providing the subprocess module pfun . subprocess . run_in_shell ( cmd , stdin =- 1 , stdout =- 1 , stderr =- 1 ) Get an Effect that runs cmd in the shell Examples: >>> class Env : ... subprocess = Subprocess () >>> run_in_shell ( 'cat foo.txt' ) . run ( Env ()) ( b 'contents of foo.txt' , b '' ) Parameters: Name Type Description Default cmd str the command to run required stdin Union[IO, int] input pipe for the subprocess -1 stdout Union[IO, int] output pipe for the subprocess -1 stderr Union[IO, int] error pipe for the subprocess -1 Returns: Type Description Effect[HasSubprocess, CalledProcessError, Tuple[bytes, bytes]] Effect that runs cmd in the shell and produces a tuple of (stdout, stderr)","title":"pfun.subprocess"},{"location":"subprocess_api/#pfun.subprocess.Subprocess","text":"Module that enables running commands in the shell","title":"Subprocess"},{"location":"subprocess_api/#pfun.subprocess.Subprocess.run_in_shell","text":"Get an Effect that runs cmd in the shell Examples: >>> Subprocess () . run_in_shell ( 'cat foo.txt' ) . run ( None ) ( b 'contents of foo.txt' , b '' ) Parameters: Name Type Description Default cmd str the command to run required stdin Union[IO, int] input pipe for the subprocess -1 stdout Union[IO, int] output pipe for the subprocess -1 stderr Union[IO, int] error pipe for the subprocess -1 Returns: Type Description Try[CalledProcessError, Tuple[bytes, bytes]] Effect that runs cmd in the shell and produces a tuple of (stdout, stderr)","title":"run_in_shell()"},{"location":"subprocess_api/#pfun.subprocess.HasSubprocess","text":"Module provider providing the subprocess module","title":"HasSubprocess"},{"location":"subprocess_api/#pfun.subprocess.run_in_shell","text":"Get an Effect that runs cmd in the shell Examples: >>> class Env : ... subprocess = Subprocess () >>> run_in_shell ( 'cat foo.txt' ) . run ( Env ()) ( b 'contents of foo.txt' , b '' ) Parameters: Name Type Description Default cmd str the command to run required stdin Union[IO, int] input pipe for the subprocess -1 stdout Union[IO, int] output pipe for the subprocess -1 stderr Union[IO, int] error pipe for the subprocess -1 Returns: Type Description Effect[HasSubprocess, CalledProcessError, Tuple[bytes, bytes]] Effect that runs cmd in the shell and produces a tuple of (stdout, stderr)","title":"run_in_shell()"},{"location":"trampoline_api/","text":"pfun.trampoline.Trampoline dataclass Base class for Trampolines. Useful for writing stack safe-safe recursive functions. and_then ( self , f ) Apply f to the value wrapped by this trampoline. Parameters: Name Type Description Default f Callable[[~A], Trampoline[B]] function to apply the value in this trampoline required Returns: Type Description Trampoline[B] Result of applying f to the value wrapped by this trampoline map ( self , f ) Map f over the value wrapped by this trampoline. Parameters: Name Type Description Default f Callable[[~A], ~B] function to wrap over this trampoline required Returns: Type Description Trampoline[B] new trampoline wrapping the result of f run ( self ) Interpret a structure of trampolines to produce a result Returns: Type Description ~A result of intepreting this structure of trampolines pfun.trampoline.Done dataclass Represents the result of a recursive computation. pfun.trampoline.Call dataclass Represents a recursive call. pfun.trampoline.AndThen dataclass Represents monadic bind for trampolines as a class to avoid deep recursive calls to Trampoline.run during interpretation. and_then ( self , f ) Apply f to the value wrapped by this trampoline. Parameters: Name Type Description Default f Callable[[~A], pfun.trampoline.Trampoline[~B]] function to apply the value in this trampoline required Returns: Type Description pfun.trampoline.Trampoline[~B] Result of applying f to the value wrapped by this trampoline pfun . trampoline . for_each ( f , iterable ) Map each in element in iterable to an Trampoline by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> map_m ( Done , range ( 3 )) . run () ( 0 , 1 , 2 ) Parameters: Name Type Description Default f Callable[[~A], pfun.trampoline.Trampoline[~B]] Function to map over iterable required iterable Iterable[~A] Iterable to map f over required Returns: Type Description pfun.trampoline.Trampoline[Iterable[~B]] f mapped over iterable and combined from left to right. pfun . trampoline . sequence ( iterable ) Evaluate each Trampoline in iterable from left to right and collect the results Examples: >>> sequence ([ Done ( v ) for v in range ( 3 )]) . run () ( 0 , 1 , 2 ) Parameters: Name Type Description Default iterable Iterable[pfun.trampoline.Trampoline[~A]] The iterable to collect results from required Returns: Type Description pfun.trampoline.Trampoline[Iterable[~A]] Trampoline of collected results pfun . trampoline . filter_ ( f , iterable ) Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter_m ( lambda v : Done ( v % 2 == 0 ), range ( 3 )) . run () ( 0 , 2 ) Parameters: Name Type Description Default f Callable[[~A], pfun.trampoline.Trampoline[bool]] Function to map iterable by required iterable Iterable[~A] Iterable to map by f required Returns: Type Description pfun.trampoline.Trampoline[Iterable[~A]] iterable mapped and filtered by f","title":"pfun.trampoline"},{"location":"trampoline_api/#pfun.trampoline.Trampoline","text":"Base class for Trampolines. Useful for writing stack safe-safe recursive functions.","title":"Trampoline"},{"location":"trampoline_api/#pfun.trampoline.Trampoline.and_then","text":"Apply f to the value wrapped by this trampoline. Parameters: Name Type Description Default f Callable[[~A], Trampoline[B]] function to apply the value in this trampoline required Returns: Type Description Trampoline[B] Result of applying f to the value wrapped by this trampoline","title":"and_then()"},{"location":"trampoline_api/#pfun.trampoline.Trampoline.map","text":"Map f over the value wrapped by this trampoline. Parameters: Name Type Description Default f Callable[[~A], ~B] function to wrap over this trampoline required Returns: Type Description Trampoline[B] new trampoline wrapping the result of f","title":"map()"},{"location":"trampoline_api/#pfun.trampoline.Trampoline.run","text":"Interpret a structure of trampolines to produce a result Returns: Type Description ~A result of intepreting this structure of trampolines","title":"run()"},{"location":"trampoline_api/#pfun.trampoline.Done","text":"Represents the result of a recursive computation.","title":"Done"},{"location":"trampoline_api/#pfun.trampoline.Call","text":"Represents a recursive call.","title":"Call"},{"location":"trampoline_api/#pfun.trampoline.AndThen","text":"Represents monadic bind for trampolines as a class to avoid deep recursive calls to Trampoline.run during interpretation.","title":"AndThen"},{"location":"trampoline_api/#pfun.trampoline.AndThen.and_then","text":"Apply f to the value wrapped by this trampoline. Parameters: Name Type Description Default f Callable[[~A], pfun.trampoline.Trampoline[~B]] function to apply the value in this trampoline required Returns: Type Description pfun.trampoline.Trampoline[~B] Result of applying f to the value wrapped by this trampoline","title":"and_then()"},{"location":"trampoline_api/#pfun.trampoline.for_each","text":"Map each in element in iterable to an Trampoline by applying f , combine the elements by and_then from left to right and collect the results Examples: >>> map_m ( Done , range ( 3 )) . run () ( 0 , 1 , 2 ) Parameters: Name Type Description Default f Callable[[~A], pfun.trampoline.Trampoline[~B]] Function to map over iterable required iterable Iterable[~A] Iterable to map f over required Returns: Type Description pfun.trampoline.Trampoline[Iterable[~B]] f mapped over iterable and combined from left to right.","title":"for_each()"},{"location":"trampoline_api/#pfun.trampoline.sequence","text":"Evaluate each Trampoline in iterable from left to right and collect the results Examples: >>> sequence ([ Done ( v ) for v in range ( 3 )]) . run () ( 0 , 1 , 2 ) Parameters: Name Type Description Default iterable Iterable[pfun.trampoline.Trampoline[~A]] The iterable to collect results from required Returns: Type Description pfun.trampoline.Trampoline[Iterable[~A]] Trampoline of collected results","title":"sequence()"},{"location":"trampoline_api/#pfun.trampoline.filter_","text":"Map each element in iterable by applying f , filter the results by the value returned by f and combine from left to right. Examples: >>> filter_m ( lambda v : Done ( v % 2 == 0 ), range ( 3 )) . run () ( 0 , 2 ) Parameters: Name Type Description Default f Callable[[~A], pfun.trampoline.Trampoline[bool]] Function to map iterable by required iterable Iterable[~A] Iterable to map by f required Returns: Type Description pfun.trampoline.Trampoline[Iterable[~A]] iterable mapped and filtered by f","title":"filter_()"},{"location":"useful_functions/","text":"curry curry makes it easy to curry functions while inferring the resulting type signature with MyPy (if the pfun MyPy plugin is enabled). The functions returned by curry support both normal and curried call styles: from pfun.functions import curry @curry def f ( a : int , b : int ) -> int : return a + b assert f ( 2 , 2 ) == 4 assert f ( 2 )( 2 ) == 4 Behind the scenes, curry simply uses functools.partial to partially apply arguments until all required arguments are provided. This means that when using optional and variadic arguments, there are many different ways to call a curried function: @curry def f ( a , b = 'b' , c = 'c' ): ... assert f ( 'a' , c = 'c' , b = 'b' ) == f ( b = 'b' )( a = 'a' ) == f ( c = 'c' )( a = 'a' )( b = 'b' ) == ... To keep things simple, the pfun MyPy plugin doesn't infer all possible overloads of curried signatures. Instead, the inferred signature is split into the following argument lists: One argument list for optional arguments and **kwargs followed by one argument list for each positional argument. If the uncurried function accepts *args , it's added to the last positional argument list of the curried function In other words, given the following function f : @curry def f ( pos_1 : T , pos_2 : T , * args : T , keyword : T = '' , ** kwargs : T ) -> T : ... the MyPy plugin infers the following overloaded signatures: Curried signature without optional arguments (pos_1: T) -> (pos_2: T, *args: T) -> T Curried signature with optional arguments (*, keyword: T =, **kwargs: T) -> (pos_1: T) -> (pos_2: T, *args: T) -> T Uncurried signature (pos_1: T, pos_2: T, *args: T, *, keyword: T =, **kwargs: T) -> T The reasoning behind this behaviour is that the main use-case for currying is to pass partially applied functions as arguments to other functions that expect unary function arguments such as pfun.effect.Effect.map or pfun.effect.Effect.and_then , and in by-far most cases, we need the required arguments to be applied last: import operator as op from pfun.functions import curry from pfun.effect import success success ( 2 ) . map ( curry ( op . add )( 2 )) . run ( None ) 4 If this is not the behaviour you need, you can cast the result of calling a curried function, or use a lambda : from typing import cast , Callable @curry def only_optional_args ( a : str = 'a' , b : str = 'b' ) -> str : ... # we need to cast here because the MyPy plugin does not infer this signature f = cast ( Callable [[ str ], str ], only_optional_args ( 'c' )) # alternatively, use a lambda f = lambda b : only_optional_args ( 'c' , b ) compose compose makes it easy to compose functions while inferring the resulting type signature with MyPy (if the pfun MyPy plugin is enabled). compose composes functions right to left: from pfun.functions import compose def f ( x ): ... def g ( x ): ... h = compose ( f , g ) # h == lambda x: f(g(x))","title":"Useful Functions"},{"location":"useful_functions/#curry","text":"curry makes it easy to curry functions while inferring the resulting type signature with MyPy (if the pfun MyPy plugin is enabled). The functions returned by curry support both normal and curried call styles: from pfun.functions import curry @curry def f ( a : int , b : int ) -> int : return a + b assert f ( 2 , 2 ) == 4 assert f ( 2 )( 2 ) == 4 Behind the scenes, curry simply uses functools.partial to partially apply arguments until all required arguments are provided. This means that when using optional and variadic arguments, there are many different ways to call a curried function: @curry def f ( a , b = 'b' , c = 'c' ): ... assert f ( 'a' , c = 'c' , b = 'b' ) == f ( b = 'b' )( a = 'a' ) == f ( c = 'c' )( a = 'a' )( b = 'b' ) == ... To keep things simple, the pfun MyPy plugin doesn't infer all possible overloads of curried signatures. Instead, the inferred signature is split into the following argument lists: One argument list for optional arguments and **kwargs followed by one argument list for each positional argument. If the uncurried function accepts *args , it's added to the last positional argument list of the curried function In other words, given the following function f : @curry def f ( pos_1 : T , pos_2 : T , * args : T , keyword : T = '' , ** kwargs : T ) -> T : ... the MyPy plugin infers the following overloaded signatures: Curried signature without optional arguments (pos_1: T) -> (pos_2: T, *args: T) -> T Curried signature with optional arguments (*, keyword: T =, **kwargs: T) -> (pos_1: T) -> (pos_2: T, *args: T) -> T Uncurried signature (pos_1: T, pos_2: T, *args: T, *, keyword: T =, **kwargs: T) -> T The reasoning behind this behaviour is that the main use-case for currying is to pass partially applied functions as arguments to other functions that expect unary function arguments such as pfun.effect.Effect.map or pfun.effect.Effect.and_then , and in by-far most cases, we need the required arguments to be applied last: import operator as op from pfun.functions import curry from pfun.effect import success success ( 2 ) . map ( curry ( op . add )( 2 )) . run ( None ) 4 If this is not the behaviour you need, you can cast the result of calling a curried function, or use a lambda : from typing import cast , Callable @curry def only_optional_args ( a : str = 'a' , b : str = 'b' ) -> str : ... # we need to cast here because the MyPy plugin does not infer this signature f = cast ( Callable [[ str ], str ], only_optional_args ( 'c' )) # alternatively, use a lambda f = lambda b : only_optional_args ( 'c' , b )","title":"curry"},{"location":"useful_functions/#compose","text":"compose makes it easy to compose functions while inferring the resulting type signature with MyPy (if the pfun MyPy plugin is enabled). compose composes functions right to left: from pfun.functions import compose def f ( x ): ... def g ( x ): ... h = compose ( f , g ) # h == lambda x: f(g(x))","title":"compose"},{"location":"what_is_this/","text":"pfun is a Python library that aims to make functional programming in Python fun and easy. On its own, Python has all the features necessary to write code in functional style. However, many programmers find functional programming in Python difficult and tedious because it lacks features supporting common functional design patterns. pfun supplies the last few puzzle pieces that make functional programming in Python ergonomical. Specifically: pfun provides a simple, unified api for working with any side-effect in functional style through a full-fledged functional effect system that doesn't rely on complex solutions such as monad transformers . Python doesn't perform tail call optimization which is a problem for many functional design patterns that rely on recursion. pfun solves this by building trampolining into all relevant types and functions pfun provides immutable data structures with a functional api, as well as tools for building your own immutable data types. The Python type annotations are often too limited to accurately type common functional design patterns. pfun solves this by including a MyPy plugin that provides very precise typing. pfun integrates functional patterns for async programming with the asyncio module. pfun differs from other libraries for functional Python programming in that pfun takes a modern approach to functional programming inspired by state of the art solutions to working with side-effects from functional programming languages (specifically the Zio Scala libary) pfun was designed with a strong emphasis on static type checking pfun is designed to be \"pythonic\", using Python conventions and best practices when possible, favouring easy to understand names over functional programming jargon, and integrating with the Python standard library as much as possible.","title":"What Is This?"}]}